
#line 1 "src/lib/eolian/eo_lexer.rl"
#include <stdio.h>
#include <stdlib.h>
#include <Eina.h>

#include "Eolian.h"
#
#include "eo_lexer.h"
#include "eolian_database.h"

static int _eo_tokenizer_log_dom = -1;
#ifdef CRITICAL
#undef CRITICAL
#endif
#define CRITICAL(...) EINA_LOG_DOM_CRIT(_eo_tokenizer_log_dom, __VA_ARGS__)

#ifdef ERR
#undef ERR
#endif
#define ERR(...) EINA_LOG_DOM_ERR(_eo_tokenizer_log_dom, __VA_ARGS__)

#ifdef WRN
#undef WRN
#endif
#define WRN(...) EINA_LOG_DOM_WARN(_eo_tokenizer_log_dom, __VA_ARGS__)

#define INF_ENABLED EINA_FALSE
#ifdef INF
#undef INF
#endif
#define INF(...) if (INF_ENABLED) EINA_LOG_DOM_INFO(_eo_tokenizer_log_dom, __VA_ARGS__)

#define DBG_ENABLED EINA_FALSE
#ifdef DBG
#undef DBG
#endif
#define DBG(...) if (DBG_ENABLED) EINA_LOG_DOM_DBG(_eo_tokenizer_log_dom, __VA_ARGS__)

#define FUNC_PUBLIC 0
#define FUNC_PROTECTED 1

static int _init_counter = 0;

int
eo_tokenizer_init()
{
   if (!_init_counter)
     {
        eina_init();
        eina_log_color_disable_set(EINA_FALSE);
        _eo_tokenizer_log_dom = eina_log_domain_register("eo_toknz", EINA_COLOR_CYAN);
     }
   return _init_counter++;
}

int
eo_tokenizer_shutdown()
{
   if (_init_counter <= 0) return 0;
   _init_counter--;
   if (!_init_counter)
     {
        eina_log_domain_unregister(_eo_tokenizer_log_dom);
        _eo_tokenizer_log_dom = -1;
        eina_shutdown();
     }
   return _init_counter;
}

static void
_eo_tokenizer_abort(Eo_Tokenizer *toknz,
                    const char *file, const char* fct, int line,
                    const char *fmt, ...)
{
   va_list ap;
   va_start (ap, fmt);
   eina_log_vprint(_eo_tokenizer_log_dom, EINA_LOG_LEVEL_ERR,
                   file, fct, line, fmt, ap);
   va_end(ap);
   fprintf(stderr, "File:%s\n toknz[%d] n:%d l:%d p:%d pe:%d ts:%s te:%s act:%d\n",
          toknz->source,
          toknz->cs, toknz->current_nesting, toknz->current_line,
          (int)(toknz->p - toknz->buf), (int)(toknz->pe - toknz->buf),
          toknz->ts, toknz->te, toknz->act);
   exit(EXIT_FAILURE);
}
#define ABORT(toknz, ...) \
   _eo_tokenizer_abort(toknz, __FILE__, __FUNCTION__, __LINE__, __VA_ARGS__);

static void _eo_tokenizer_normalize_buf(char *buf)
{
   int c;
   char *s, *d;
   Eina_Bool in_space = EINA_TRUE;
   Eina_Bool in_newline = EINA_FALSE;

   /* ' '+ -> ' '
    * '\n' ' '* '*' ' '* -> '\n'
    */
   for (s = buf, d = buf; *s != '\0'; s++)
     {
        c = *s;
        *d = c;

        if (!in_space || (c != ' '))
          d++;

        if (c == ' ')
          in_space = EINA_TRUE;
        else
          in_space = EINA_FALSE;

        if (c == '\n')
          {
             in_newline = EINA_TRUE;
             in_space = EINA_TRUE;
          }
        else if (in_newline && c == '*' )
          {
             in_space = EINA_TRUE;
             in_newline = EINA_FALSE;
             d--;
          }
     }
   /* ' '+$ -> $ */
   d--;
   while (*d == ' ') d--;
   d++;
   if (d < buf) return;
   *d = '\0';
}

static const char*
_eo_tokenizer_token_get(Eo_Tokenizer *toknz, char *p)
{
   if (toknz->saved.tok == NULL) ABORT(toknz, "toknz->saved.tok is NULL");
   char d[BUFSIZE];
   int l = (p - toknz->saved.tok);
   memcpy(d, toknz->saved.tok, l);
   d[l] = '\0';
   _eo_tokenizer_normalize_buf(d);
   toknz->saved.tok = NULL;
   DBG("token : >%s<", d);
   return eina_stringshare_add(d);
}

static Eo_Class_Def*
_eo_tokenizer_class_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Class_Def *kls = calloc(1, sizeof(Eo_Class_Def));
   if (kls == NULL) ABORT(toknz, "calloc Eo_Class_Def failure");

   kls->name = _eo_tokenizer_token_get(toknz, p);

   return kls;
}

static Eo_Type_Def*
_eo_tokenizer_type_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Type_Def *def = calloc(1, sizeof(Eo_Type_Def));
   if (def == NULL) ABORT(toknz, "calloc Eo_Type_Def failure");

   def->type = _eo_tokenizer_token_get(toknz, p);

   return def;
}

static Eo_Property_Def*
_eo_tokenizer_property_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Property_Def *prop = calloc(1, sizeof(Eo_Property_Def));
   if (prop == NULL) ABORT(toknz, "calloc Eo_Property_Def failure");

   prop->name = _eo_tokenizer_token_get(toknz, p);
   prop->scope = toknz->tmp.fscope;
   toknz->tmp.fscope = FUNC_PUBLIC;

   return prop;
}

static Eo_Method_Def*
_eo_tokenizer_method_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Method_Def *meth = calloc(1, sizeof(Eo_Method_Def));
   if (meth == NULL) ABORT(toknz, "calloc Eo_Method_Def failure");

   meth->name = _eo_tokenizer_token_get(toknz, p);
   meth->scope = toknz->tmp.fscope;
   toknz->tmp.fscope = FUNC_PUBLIC;

   return meth;
}

static int
_eo_tokenizer_scope_get(Eo_Tokenizer *toknz, EINA_UNUSED char *p)
{
   if (!strncmp(toknz->saved.tok, "protected ", 10))
     return FUNC_PROTECTED;

   return FUNC_PUBLIC;
}

static Eo_Param_Def*
_eo_tokenizer_param_get(Eo_Tokenizer *toknz, char *p)
{
   char *s;

   Eo_Param_Def *param = calloc(1, sizeof(Eo_Param_Def));
   if (param == NULL) ABORT(toknz, "calloc Eo_Param_Def failure");

   /* The next code part tries to identify the different tags of the
      parameter.
      First, we set the ';' to '\0', to search only inside this section.
      We then strstr the different tags and if found, we update the internal
      flag and clear the zone of the text. In this way, during the
      determination of the type/variable, we will not be disturbed by the
      flags.
      We have to put back the ';' at the end.
    */
   *p = '\0';
   s = strstr(toknz->saved.tok, "@nonull");
   if (s)
     {
        param->nonull = EINA_TRUE;
        memset(s, ' ', 7);
     }
   *p = ';';
   s = p - 1; /* Don't look at the character ';' */
   /* Remove any space between the param name and ';'/@nonull
    * This loop fixes the case where "char *name ;" becomes the type of the param.
    */
   while (*s == ' ') s--;
   for (; s >= toknz->saved.tok; s--)
     {
        if ((*s == ' ') || (*s == '*'))
          break;
     }

   if (s == toknz->saved.tok)
     ABORT(toknz, "wrong parameter: %s", _eo_tokenizer_token_get(toknz, p));
   s++;

   param->way = PARAM_IN;
   if (strncmp(toknz->saved.tok, "@in ", 4) == 0)
     {
        toknz->saved.tok += 3;
        param->way = PARAM_IN;
     }
   else if (strncmp(toknz->saved.tok, "@out ", 5) == 0)
     {
        toknz->saved.tok += 4;
        param->way = PARAM_OUT;
     }
   else if (strncmp(toknz->saved.tok, "@inout ", 7) == 0)
     {
        toknz->saved.tok += 6;
        param->way = PARAM_INOUT;
     }

   param->type = _eo_tokenizer_token_get(toknz, s);

   toknz->saved.tok = s;
   param->name = _eo_tokenizer_token_get(toknz, p);

   return param;
}

static Eo_Ret_Def*
_eo_tokenizer_return_get(Eo_Tokenizer *toknz, char *p)
{
   char *s;

   Eo_Ret_Def *ret = calloc(1, sizeof(Eo_Ret_Def));
   if (ret == NULL) ABORT(toknz, "calloc Eo_Ret_Def failure");

   *p = '\0';
   s = strstr(toknz->saved.tok, "@warn_unused");
   if (s)
     {
        ret->warn_unused = EINA_TRUE;
        memset(s, ' ', 12);
     }
   s = strchr(toknz->saved.tok, '(');
   if (s)
     {
        char *ret_val;
        char *end = strchr(s, ')');
        if (!end)
           ABORT(toknz, "wrong syntax (missing ')'): %s",
                 _eo_tokenizer_token_get(toknz, p));
        /* Current values in s and end have to be changed to ' ' to not disturb the next steps (type extraction) */
        *s++ = ' ';
        while (*s == ' ') s++;
        *end-- = ' ';
        while (end > s && *end == ' ') end--;
        if (end < s)
           ABORT(toknz, "empty default return value: %s",
                 _eo_tokenizer_token_get(toknz, p));
        ret_val = malloc(end - s + 2); /* string + '\0' */
        memcpy(ret_val, s, end - s + 1);
        ret_val[end - s + 1] = '\0';
        ret->dflt_ret_val = ret_val;
        memset(s, ' ', end - s + 1);
     }
   *p = ';';
   s = p - 1; /* Don't look at the character ';' */
   /* Remove any space between the param name and ';'
    * This loop fixes the case where "char *name ;" becomes the type of the param.
    */
   while (*s == ' ') s--;

   if (s == toknz->saved.tok)
     ABORT(toknz, "wrong parameter: %s", _eo_tokenizer_token_get(toknz, p));
   s++;

   ret->type = _eo_tokenizer_token_get(toknz, s);

   return ret;
}

static Eo_Accessor_Param*
_eo_tokenizer_accessor_param_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Accessor_Param *param = calloc(1, sizeof(Eo_Accessor_Param));
   if (param == NULL) ABORT(toknz, "calloc Eo_Accessor_Param failure");

   /* Remove the colon and spaces - we just need the param name */
   while (*p != ':') p--;
   p--;
   while (*p == ' ') p--;
   param->name = _eo_tokenizer_token_get(toknz, p + 1);

   return param;
}

static Eo_Accessor_Def *
_eo_tokenizer_accessor_get(Eo_Tokenizer *toknz, Eo_Accessor_Type type)
{
   Eo_Accessor_Def *accessor = calloc(1, sizeof(Eo_Accessor_Def));
   if (accessor == NULL) ABORT(toknz, "calloc Eo_Accessor_Def failure");

   accessor->type = type;

   return accessor;
}

static Eo_Event_Def*
_eo_tokenizer_event_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Event_Def *sgn = calloc(1, sizeof(Eo_Event_Def));
   if (sgn == NULL) ABORT(toknz, "calloc Eo_Event_Def failure");

   sgn->name = _eo_tokenizer_token_get(toknz, p);

   return sgn;
}

static Eo_Implement_Def*
_eo_tokenizer_implement_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Implement_Def *impl = calloc(1, sizeof(Eo_Implement_Def));
   if (impl == NULL) ABORT(toknz, "calloc Eo_Implement_Def failure");

   impl->meth_name = _eo_tokenizer_token_get(toknz, p);

   return impl;
}


#line 454 "src/lib/eolian/eo_lexer.rl"



#line 377 "src/lib/eolian/eo_lexer.c"
static const char _eo_tokenizer_actions[] = {
	0, 1, 0, 1, 1, 1, 2, 1, 
	7, 1, 12, 1, 19, 1, 21, 1, 
	22, 1, 23, 1, 24, 1, 25, 1, 
	26, 1, 27, 1, 28, 1, 29, 1, 
	30, 1, 31, 1, 32, 1, 33, 1, 
	34, 1, 35, 1, 37, 1, 38, 1, 
	39, 1, 40, 1, 41, 1, 44, 1, 
	45, 1, 46, 1, 47, 1, 48, 1, 
	49, 1, 50, 1, 51, 1, 52, 1, 
	53, 1, 54, 1, 55, 1, 56, 1, 
	57, 1, 58, 1, 59, 1, 60, 1, 
	61, 1, 62, 1, 63, 1, 64, 1, 
	65, 1, 67, 1, 68, 1, 69, 1, 
	70, 1, 71, 1, 72, 1, 73, 1, 
	74, 1, 75, 1, 76, 1, 77, 1, 
	78, 1, 79, 1, 80, 1, 81, 1, 
	82, 1, 83, 1, 87, 1, 88, 1, 
	89, 1, 90, 1, 91, 1, 92, 1, 
	93, 1, 94, 1, 95, 1, 96, 1, 
	97, 1, 98, 1, 99, 1, 100, 1, 
	101, 1, 102, 1, 103, 1, 104, 1, 
	105, 1, 106, 1, 107, 1, 108, 1, 
	109, 1, 110, 1, 111, 1, 112, 1, 
	113, 1, 114, 1, 115, 1, 116, 1, 
	117, 1, 118, 1, 119, 1, 120, 1, 
	121, 1, 122, 1, 124, 1, 125, 1, 
	126, 1, 127, 2, 0, 41, 2, 0, 
	52, 2, 0, 61, 2, 0, 73, 2, 
	0, 82, 2, 0, 95, 2, 0, 104, 
	2, 0, 121, 2, 5, 47, 2, 6, 
	42, 2, 7, 2, 2, 8, 43, 2, 
	9, 56, 2, 11, 66, 2, 12, 0, 
	2, 12, 74, 2, 15, 90, 2, 16, 
	84, 2, 17, 85, 2, 18, 86, 2, 
	19, 0, 2, 19, 96, 2, 21, 0, 
	2, 22, 0, 2, 22, 122, 2, 23, 
	0, 2, 24, 0, 2, 25, 0, 2, 
	25, 1, 2, 25, 2, 2, 29, 0, 
	2, 34, 0, 2, 34, 122, 2, 36, 
	123, 2, 39, 1, 2, 39, 2, 2, 
	39, 4, 2, 39, 10, 2, 39, 14, 
	3, 3, 13, 2, 3, 3, 20, 2
	
};

static const short _eo_tokenizer_key_offsets[] = {
	0, 2, 5, 6, 7, 8, 9, 10, 
	11, 12, 15, 22, 38, 42, 50, 55, 
	59, 72, 77, 84, 85, 86, 87, 88, 
	89, 92, 93, 94, 95, 96, 97, 98, 
	99, 102, 103, 104, 105, 108, 109, 110, 
	113, 120, 131, 135, 142, 155, 169, 172, 
	174, 177, 188, 190, 193, 194, 198, 205, 
	212, 224, 235, 247, 259, 271, 283, 294, 
	302, 310, 322, 334, 346, 358, 369, 386, 
	403, 420, 437, 441, 442, 443, 453, 455, 
	458, 474, 476, 479, 480, 494, 498, 499, 
	500, 510, 512, 515, 517, 520, 521, 522, 
	523, 524, 525, 526, 527, 528, 529, 530, 
	531, 532, 536, 537, 538, 542, 543, 547, 
	548, 549, 550, 551, 555, 557, 560, 561, 
	565, 576, 586, 598, 610, 622, 634, 646, 
	658, 670, 680, 690, 703, 715, 727, 739, 
	751, 763, 775, 787, 794, 806, 818, 830, 
	842, 854, 866, 878, 890, 893, 895, 898, 
	909, 911, 914, 915, 916, 917, 918, 920, 
	921, 922, 923, 924, 925, 926, 927, 928, 
	929, 930, 933, 940, 948, 949, 950, 951, 
	952, 956, 957, 958, 959, 960, 963, 979, 
	995, 1012, 1029, 1033, 1034, 1035, 1045, 1047, 
	1050, 1066, 1068, 1071, 1072, 1076, 1087, 1097, 
	1109, 1121, 1133, 1145, 1157, 1169, 1181, 1191, 
	1201, 1214, 1226, 1238, 1250, 1262, 1274, 1286, 
	1298, 1305, 1317, 1329, 1341, 1353, 1365, 1377, 
	1389, 1401, 1404, 1406, 1409, 1420, 1422, 1425, 
	1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 
	1434, 1435, 1436, 1440, 1441, 1442, 1446, 1453, 
	1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 
	1472, 1479, 1487, 1488, 1489, 1490, 1491, 1495, 
	1503, 1519, 1523, 1535, 1544, 1546, 1548, 1551, 
	1560, 1561, 1563, 1566, 1577, 1579, 1582, 1591, 
	1599, 1607, 1619, 1623, 1624, 1625, 1626, 1627, 
	1628, 1629, 1630, 1631, 1635, 1643, 1655, 1659, 
	1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 
	1668, 1669, 1670, 1671, 1675, 1682, 1690, 1691, 
	1692, 1693, 1694, 1695, 1699, 1700, 1701, 1702, 
	1703, 1704, 1705, 1706, 1707, 1711, 1720, 1723, 
	1725, 1726, 1727, 1728, 1729, 1730, 1741, 1744, 
	1746, 1757, 1769, 1781, 1785, 1785, 1786, 1795, 
	1798, 1800, 1813, 1817, 1817, 1818, 1828, 1831, 
	1833, 1834, 1835, 1836, 1837, 1838, 1839, 1851, 
	1854, 1856, 1867, 1880, 1881, 1890, 1893, 1895, 
	1896, 1897, 1898, 1899, 1903, 1903, 1904, 1916, 
	1919, 1921, 1932, 1945, 1946, 1958, 1961, 1963, 
	1964, 1965, 1968, 1970, 1973, 1974, 1975, 1976, 
	1977, 1980, 1981, 1982
};

static const char _eo_tokenizer_trans_keys[] = {
	10, 42, 10, 42, 47, 10, 115, 116, 
	114, 97, 99, 116, 9, 13, 32, 9, 
	13, 32, 65, 90, 97, 122, 9, 10, 
	13, 32, 40, 58, 95, 123, 0, 31, 
	48, 57, 65, 90, 97, 122, 10, 123, 
	0, 32, 9, 10, 13, 32, 40, 123, 
	0, 31, 41, 65, 90, 97, 122, 10, 
	123, 0, 32, 10, 41, 44, 58, 95, 
	0, 32, 48, 57, 65, 90, 97, 122, 
	10, 41, 44, 0, 32, 10, 0, 32, 
	65, 90, 97, 122, 58, 58, 97, 115, 
	115, 9, 13, 32, 116, 101, 114, 102, 
	97, 99, 101, 9, 13, 32, 120, 105, 
	110, 9, 13, 32, 112, 101, 9, 13, 
	32, 9, 13, 32, 65, 90, 97, 122, 
	9, 13, 32, 58, 95, 48, 57, 65, 
	90, 97, 122, 9, 13, 32, 58, 9, 
	13, 32, 64, 90, 97, 122, 9, 13, 
	32, 42, 60, 62, 95, 48, 57, 64, 
	90, 97, 122, 9, 13, 32, 42, 59, 
	60, 62, 95, 48, 57, 64, 90, 97, 
	122, 10, 42, 64, 10, 42, 10, 42, 
	47, 10, 42, 95, 0, 32, 48, 57, 
	64, 90, 97, 122, 10, 42, 10, 42, 
	47, 10, 9, 13, 32, 58, 9, 13, 
	32, 65, 90, 97, 122, 9, 13, 32, 
	65, 90, 97, 122, 9, 13, 32, 44, 
	59, 95, 48, 57, 65, 90, 97, 122, 
	9, 13, 32, 58, 95, 48, 57, 65, 
	90, 97, 122, 9, 13, 32, 58, 95, 
	103, 48, 57, 65, 90, 97, 122, 9, 
	13, 32, 58, 95, 97, 48, 57, 65, 
	90, 98, 122, 9, 13, 32, 58, 95, 
	99, 48, 57, 65, 90, 97, 122, 9, 
	13, 32, 58, 95, 121, 48, 57, 65, 
	90, 97, 122, 9, 13, 32, 58, 95, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 58, 65, 90, 97, 122, 59, 95, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 58, 95, 116, 48, 57, 65, 90, 
	97, 122, 9, 13, 32, 58, 95, 117, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 58, 95, 114, 48, 57, 65, 90, 
	97, 122, 9, 13, 32, 58, 95, 110, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 58, 95, 48, 57, 65, 90, 97, 
	122, 9, 13, 32, 58, 60, 62, 95, 
	40, 42, 45, 46, 48, 57, 64, 90, 
	97, 122, 9, 13, 32, 58, 60, 62, 
	95, 40, 42, 45, 46, 48, 57, 64, 
	90, 97, 122, 9, 13, 32, 58, 59, 
	62, 95, 40, 42, 45, 46, 48, 60, 
	64, 90, 97, 122, 9, 13, 32, 59, 
	60, 62, 95, 40, 42, 45, 46, 48, 
	57, 64, 90, 97, 122, 9, 13, 32, 
	47, 42, 64, 10, 95, 0, 32, 48, 
	57, 64, 90, 97, 122, 10, 42, 10, 
	42, 47, 9, 13, 32, 60, 62, 95, 
	40, 42, 45, 46, 48, 57, 64, 90, 
	97, 122, 10, 42, 10, 42, 47, 10, 
	9, 13, 32, 42, 59, 60, 62, 95, 
	48, 57, 64, 90, 97, 122, 9, 13, 
	32, 47, 42, 64, 10, 95, 0, 32, 
	48, 57, 64, 90, 97, 122, 10, 42, 
	10, 42, 47, 10, 42, 10, 42, 47, 
	10, 110, 115, 116, 114, 117, 99, 116, 
	111, 114, 59, 116, 10, 123, 0, 32, 
	121, 115, 10, 123, 0, 32, 116, 10, 
	123, 0, 32, 108, 117, 101, 115, 10, 
	123, 0, 32, 10, 42, 10, 42, 47, 
	10, 10, 123, 0, 32, 10, 95, 123, 
	0, 32, 48, 57, 65, 90, 97, 122, 
	10, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 111, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	116, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 101, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	99, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 116, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	101, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 100, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 95, 48, 57, 65, 90, 97, 122, 
	9, 13, 32, 112, 48, 57, 65, 90, 
	97, 122, 10, 95, 114, 117, 123, 0, 
	32, 48, 57, 65, 90, 97, 122, 10, 
	95, 111, 123, 0, 32, 48, 57, 65, 
	90, 97, 122, 10, 95, 116, 123, 0, 
	32, 48, 57, 65, 90, 97, 122, 10, 
	95, 101, 123, 0, 32, 48, 57, 65, 
	90, 97, 122, 10, 95, 99, 123, 0, 
	32, 48, 57, 65, 90, 97, 122, 10, 
	95, 116, 123, 0, 32, 48, 57, 65, 
	90, 97, 122, 10, 95, 101, 123, 0, 
	32, 48, 57, 65, 90, 97, 122, 10, 
	95, 100, 123, 0, 32, 48, 57, 65, 
	90, 97, 122, 95, 48, 57, 65, 90, 
	97, 122, 10, 95, 98, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	108, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 105, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	99, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 98, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	108, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 105, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	99, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 42, 64, 10, 42, 10, 
	42, 47, 10, 42, 95, 0, 32, 48, 
	57, 64, 90, 97, 122, 10, 42, 10, 
	42, 47, 10, 110, 115, 116, 59, 114, 
	117, 99, 116, 111, 114, 59, 103, 97, 
	99, 121, 9, 13, 32, 9, 13, 32, 
	65, 90, 97, 122, 59, 95, 48, 57, 
	65, 90, 97, 122, 114, 97, 109, 115, 
	10, 123, 0, 32, 116, 117, 114, 110, 
	9, 13, 32, 9, 13, 32, 60, 62, 
	95, 40, 42, 45, 46, 48, 57, 64, 
	90, 97, 122, 9, 13, 32, 60, 62, 
	95, 40, 42, 45, 46, 48, 57, 64, 
	90, 97, 122, 9, 13, 32, 59, 60, 
	62, 95, 40, 42, 45, 46, 48, 57, 
	64, 90, 97, 122, 9, 13, 32, 59, 
	60, 62, 95, 40, 42, 45, 46, 48, 
	57, 64, 90, 97, 122, 9, 13, 32, 
	47, 42, 64, 10, 95, 0, 32, 48, 
	57, 64, 90, 97, 122, 10, 42, 10, 
	42, 47, 9, 13, 32, 60, 62, 95, 
	40, 42, 45, 46, 48, 57, 64, 90, 
	97, 122, 10, 42, 10, 42, 47, 10, 
	10, 123, 0, 32, 10, 95, 123, 0, 
	32, 48, 57, 65, 90, 97, 122, 10, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 95, 111, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 95, 116, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 95, 101, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 95, 99, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 95, 116, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 95, 101, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 95, 100, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 9, 13, 32, 
	95, 48, 57, 65, 90, 97, 122, 9, 
	13, 32, 112, 48, 57, 65, 90, 97, 
	122, 10, 95, 114, 117, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	111, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 116, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	101, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 99, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	116, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 95, 101, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 10, 95, 
	100, 123, 0, 32, 48, 57, 65, 90, 
	97, 122, 95, 48, 57, 65, 90, 97, 
	122, 10, 95, 98, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 95, 108, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 95, 105, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 95, 99, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 95, 98, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 95, 108, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 95, 105, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 95, 99, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 10, 42, 64, 10, 42, 10, 42, 
	47, 10, 42, 95, 0, 32, 48, 57, 
	64, 90, 97, 122, 10, 42, 10, 42, 
	47, 10, 110, 115, 116, 114, 117, 99, 
	116, 111, 114, 115, 10, 123, 0, 32, 
	116, 97, 10, 58, 0, 32, 10, 0, 
	32, 65, 90, 97, 122, 59, 95, 48, 
	57, 65, 90, 97, 122, 95, 112, 114, 
	101, 102, 105, 120, 10, 58, 0, 32, 
	10, 0, 32, 65, 90, 97, 122, 59, 
	95, 48, 57, 65, 90, 97, 122, 101, 
	110, 116, 115, 10, 123, 0, 32, 10, 
	125, 0, 32, 65, 90, 97, 122, 9, 
	10, 13, 32, 40, 44, 59, 95, 0, 
	31, 48, 57, 65, 90, 97, 122, 10, 
	59, 0, 32, 9, 10, 13, 32, 47, 
	125, 0, 31, 65, 90, 97, 122, 10, 
	47, 125, 0, 32, 65, 90, 97, 122, 
	42, 47, 10, 42, 10, 42, 47, 10, 
	47, 125, 0, 32, 65, 90, 97, 122, 
	10, 42, 47, 10, 42, 64, 10, 42, 
	95, 0, 32, 48, 57, 64, 90, 97, 
	122, 10, 42, 10, 42, 47, 10, 47, 
	125, 0, 32, 65, 90, 97, 122, 9, 
	10, 13, 32, 40, 59, 0, 31, 9, 
	13, 32, 95, 65, 90, 97, 122, 9, 
	13, 32, 41, 42, 95, 48, 57, 65, 
	90, 97, 122, 10, 59, 0, 32, 112, 
	108, 101, 109, 101, 110, 116, 115, 10, 
	123, 0, 32, 10, 125, 0, 32, 65, 
	90, 97, 122, 10, 58, 59, 95, 0, 
	32, 48, 57, 65, 90, 97, 122, 10, 
	59, 0, 32, 58, 103, 97, 99, 121, 
	95, 112, 114, 101, 102, 105, 120, 10, 
	58, 0, 32, 10, 0, 32, 65, 90, 
	97, 122, 59, 95, 48, 57, 65, 90, 
	97, 122, 116, 104, 111, 100, 115, 10, 
	123, 0, 32, 111, 112, 101, 114, 116, 
	105, 101, 115, 10, 123, 0, 32, 10, 
	47, 97, 99, 105, 109, 116, 0, 32, 
	10, 0, 32, 42, 47, 98, 108, 110, 
	105, 121, 10, 47, 108, 114, 125, 0, 
	32, 65, 90, 97, 122, 10, 0, 32, 
	42, 47, 9, 13, 32, 58, 95, 48, 
	57, 65, 90, 97, 122, 9, 13, 32, 
	58, 95, 101, 48, 57, 65, 90, 97, 
	122, 9, 13, 32, 58, 95, 101, 48, 
	57, 65, 90, 97, 122, 9, 13, 32, 
	47, 59, 10, 47, 125, 0, 32, 64, 
	90, 97, 122, 10, 0, 32, 42, 47, 
	9, 13, 32, 42, 60, 62, 95, 48, 
	57, 64, 90, 97, 122, 9, 13, 32, 
	47, 59, 10, 47, 99, 103, 107, 115, 
	118, 125, 0, 32, 10, 0, 32, 42, 
	47, 111, 101, 101, 101, 97, 59, 10, 
	47, 112, 125, 0, 32, 48, 57, 65, 
	90, 97, 122, 10, 0, 32, 42, 47, 
	10, 95, 123, 0, 32, 48, 57, 65, 
	90, 97, 122, 10, 95, 114, 117, 123, 
	0, 32, 48, 57, 65, 90, 97, 122, 
	59, 10, 47, 99, 108, 112, 114, 125, 
	0, 32, 10, 0, 32, 42, 47, 111, 
	101, 97, 101, 9, 13, 32, 47, 59, 
	10, 47, 112, 125, 0, 32, 48, 57, 
	65, 90, 97, 122, 10, 0, 32, 42, 
	47, 10, 95, 123, 0, 32, 48, 57, 
	65, 90, 97, 122, 10, 95, 114, 117, 
	123, 0, 32, 48, 57, 65, 90, 97, 
	122, 59, 10, 47, 99, 100, 101, 105, 
	108, 109, 112, 125, 0, 32, 10, 0, 
	32, 42, 47, 111, 97, 10, 0, 32, 
	111, 118, 10, 0, 32, 59, 109, 59, 
	101, 10, 0, 32, 101, 114, 59, 0
};

static const char _eo_tokenizer_single_lengths[] = {
	2, 3, 1, 1, 1, 1, 1, 1, 
	1, 3, 3, 8, 2, 6, 1, 2, 
	5, 3, 1, 1, 1, 1, 1, 1, 
	3, 1, 1, 1, 1, 1, 1, 1, 
	3, 1, 1, 1, 3, 1, 1, 3, 
	3, 5, 4, 3, 7, 8, 3, 2, 
	3, 3, 2, 3, 1, 4, 3, 3, 
	6, 5, 6, 6, 6, 6, 5, 4, 
	2, 6, 6, 6, 6, 5, 7, 7, 
	7, 7, 4, 1, 1, 2, 2, 3, 
	6, 2, 3, 1, 8, 4, 1, 1, 
	2, 2, 3, 2, 3, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 2, 1, 1, 2, 1, 2, 1, 
	1, 1, 1, 2, 2, 3, 1, 2, 
	3, 2, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 5, 4, 4, 4, 4, 
	4, 4, 4, 1, 4, 4, 4, 4, 
	4, 4, 4, 4, 3, 2, 3, 3, 
	2, 3, 1, 1, 1, 1, 2, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 3, 3, 2, 1, 1, 1, 1, 
	2, 1, 1, 1, 1, 3, 6, 6, 
	7, 7, 4, 1, 1, 2, 2, 3, 
	6, 2, 3, 1, 2, 3, 2, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	5, 4, 4, 4, 4, 4, 4, 4, 
	1, 4, 4, 4, 4, 4, 4, 4, 
	4, 3, 2, 3, 3, 2, 3, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 2, 1, 1, 2, 1, 2, 
	1, 1, 1, 1, 1, 1, 1, 2, 
	1, 2, 1, 1, 1, 1, 2, 2, 
	8, 2, 6, 3, 2, 2, 3, 3, 
	1, 2, 3, 3, 2, 3, 3, 6, 
	4, 6, 2, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 2, 4, 2, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 1, 2, 1, 1, 
	1, 1, 1, 2, 1, 1, 1, 1, 
	1, 1, 1, 1, 2, 7, 1, 2, 
	1, 1, 1, 1, 1, 5, 1, 2, 
	5, 6, 6, 4, 0, 1, 3, 1, 
	2, 7, 4, 0, 1, 8, 1, 2, 
	1, 1, 1, 1, 1, 1, 4, 1, 
	2, 3, 5, 1, 7, 1, 2, 1, 
	1, 1, 1, 4, 0, 1, 4, 1, 
	2, 3, 5, 1, 10, 1, 2, 1, 
	1, 1, 2, 1, 1, 1, 1, 1, 
	1, 1, 1, 1
};

static const char _eo_tokenizer_range_lengths[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 2, 4, 1, 1, 2, 1, 
	4, 1, 3, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	2, 3, 0, 2, 3, 3, 0, 0, 
	0, 4, 0, 0, 0, 0, 2, 2, 
	3, 3, 3, 3, 3, 3, 3, 2, 
	3, 3, 3, 3, 3, 3, 5, 5, 
	5, 5, 0, 0, 0, 4, 0, 0, 
	5, 0, 0, 0, 3, 0, 0, 0, 
	4, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 1, 0, 1, 0, 
	0, 0, 0, 1, 0, 0, 0, 1, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 3, 3, 4, 4, 4, 4, 4, 
	4, 4, 4, 3, 4, 4, 4, 4, 
	4, 4, 4, 4, 0, 0, 0, 4, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 2, 3, 0, 0, 0, 0, 
	1, 0, 0, 0, 0, 0, 5, 5, 
	5, 5, 0, 0, 0, 4, 0, 0, 
	5, 0, 0, 0, 1, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 3, 3, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	3, 4, 4, 4, 4, 4, 4, 4, 
	4, 0, 0, 0, 4, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 0, 0, 1, 3, 3, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	3, 3, 0, 0, 0, 0, 1, 3, 
	4, 1, 3, 3, 0, 0, 0, 3, 
	0, 0, 0, 4, 0, 0, 3, 1, 
	2, 3, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 3, 4, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 3, 3, 0, 0, 
	0, 0, 0, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 3, 1, 0, 
	3, 3, 3, 0, 0, 0, 3, 1, 
	0, 3, 0, 0, 0, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 4, 1, 
	0, 4, 4, 0, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 4, 1, 
	0, 4, 4, 0, 1, 1, 0, 0, 
	0, 1, 0, 1, 0, 0, 0, 0, 
	1, 0, 0, 0
};

static const short _eo_tokenizer_index_offsets[] = {
	0, 3, 7, 9, 11, 13, 15, 17, 
	19, 21, 25, 31, 44, 48, 56, 60, 
	64, 74, 79, 84, 86, 88, 90, 92, 
	94, 98, 100, 102, 104, 106, 108, 110, 
	112, 116, 118, 120, 122, 126, 128, 130, 
	134, 140, 149, 154, 160, 171, 183, 187, 
	190, 194, 202, 205, 209, 211, 216, 222, 
	228, 238, 247, 257, 267, 277, 287, 296, 
	303, 309, 319, 329, 339, 349, 358, 371, 
	384, 397, 410, 415, 417, 419, 426, 429, 
	433, 445, 448, 452, 454, 466, 471, 473, 
	475, 482, 485, 489, 492, 496, 498, 500, 
	502, 504, 506, 508, 510, 512, 514, 516, 
	518, 520, 524, 526, 528, 532, 534, 538, 
	540, 542, 544, 546, 550, 553, 557, 559, 
	563, 571, 578, 587, 596, 605, 614, 623, 
	632, 641, 649, 657, 667, 676, 685, 694, 
	703, 712, 721, 730, 735, 744, 753, 762, 
	771, 780, 789, 798, 807, 811, 814, 818, 
	826, 829, 833, 835, 837, 839, 841, 844, 
	846, 848, 850, 852, 854, 856, 858, 860, 
	862, 864, 868, 874, 880, 882, 884, 886, 
	888, 892, 894, 896, 898, 900, 904, 916, 
	928, 941, 954, 959, 961, 963, 970, 973, 
	977, 989, 992, 996, 998, 1002, 1010, 1017, 
	1026, 1035, 1044, 1053, 1062, 1071, 1080, 1088, 
	1096, 1106, 1115, 1124, 1133, 1142, 1151, 1160, 
	1169, 1174, 1183, 1192, 1201, 1210, 1219, 1228, 
	1237, 1246, 1250, 1253, 1257, 1265, 1268, 1272, 
	1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 
	1290, 1292, 1294, 1298, 1300, 1302, 1306, 1311, 
	1317, 1319, 1321, 1323, 1325, 1327, 1329, 1331, 
	1335, 1340, 1346, 1348, 1350, 1352, 1354, 1358, 
	1364, 1377, 1381, 1391, 1398, 1401, 1404, 1408, 
	1415, 1417, 1420, 1424, 1432, 1435, 1439, 1446, 
	1454, 1461, 1471, 1475, 1477, 1479, 1481, 1483, 
	1485, 1487, 1489, 1491, 1495, 1501, 1510, 1514, 
	1516, 1518, 1520, 1522, 1524, 1526, 1528, 1530, 
	1532, 1534, 1536, 1538, 1542, 1547, 1553, 1555, 
	1557, 1559, 1561, 1563, 1567, 1569, 1571, 1573, 
	1575, 1577, 1579, 1581, 1583, 1587, 1596, 1599, 
	1602, 1604, 1606, 1608, 1610, 1612, 1621, 1624, 
	1627, 1636, 1646, 1656, 1661, 1662, 1664, 1671, 
	1674, 1677, 1688, 1693, 1694, 1696, 1706, 1709, 
	1712, 1714, 1716, 1718, 1720, 1722, 1724, 1733, 
	1736, 1739, 1747, 1757, 1759, 1768, 1771, 1774, 
	1776, 1778, 1780, 1782, 1787, 1788, 1790, 1799, 
	1802, 1805, 1813, 1823, 1825, 1837, 1840, 1843, 
	1845, 1847, 1850, 1853, 1856, 1858, 1860, 1862, 
	1864, 1867, 1869, 1871
};

static const short _eo_tokenizer_indicies[] = {
	2, 3, 1, 2, 3, 4, 1, 6, 
	5, 7, 0, 8, 0, 9, 0, 10, 
	0, 11, 0, 12, 0, 13, 13, 13, 
	0, 14, 14, 14, 15, 15, 0, 17, 
	18, 17, 17, 19, 21, 20, 22, 16, 
	20, 20, 20, 0, 24, 25, 23, 0, 
	26, 24, 26, 26, 27, 25, 23, 0, 
	28, 29, 29, 0, 31, 32, 30, 0, 
	34, 35, 36, 38, 37, 33, 37, 37, 
	37, 0, 40, 28, 41, 39, 0, 42, 
	41, 29, 29, 0, 37, 0, 20, 0, 
	43, 0, 44, 0, 45, 0, 46, 46, 
	46, 0, 47, 0, 48, 0, 49, 0, 
	50, 0, 51, 0, 52, 0, 53, 0, 
	54, 54, 54, 0, 55, 0, 56, 0, 
	57, 0, 58, 58, 58, 0, 59, 0, 
	60, 0, 61, 61, 61, 0, 61, 61, 
	61, 62, 62, 0, 63, 63, 63, 65, 
	64, 64, 64, 64, 0, 66, 66, 66, 
	67, 0, 67, 67, 67, 68, 68, 0, 
	69, 69, 69, 69, 69, 69, 69, 69, 
	69, 69, 0, 69, 69, 69, 69, 70, 
	69, 69, 69, 69, 69, 69, 0, 73, 
	74, 75, 72, 73, 74, 72, 73, 74, 
	76, 72, 77, 74, 78, 75, 78, 78, 
	78, 72, 80, 81, 79, 80, 81, 82, 
	79, 84, 83, 85, 85, 85, 86, 71, 
	87, 87, 87, 88, 88, 71, 89, 89, 
	89, 90, 90, 71, 91, 91, 91, 91, 
	92, 91, 91, 91, 91, 71, 85, 85, 
	85, 86, 93, 93, 93, 93, 71, 85, 
	85, 85, 86, 93, 94, 93, 93, 93, 
	71, 85, 85, 85, 86, 93, 95, 93, 
	93, 93, 71, 85, 85, 85, 86, 93, 
	96, 93, 93, 93, 71, 85, 85, 85, 
	86, 93, 97, 93, 93, 93, 71, 98, 
	98, 98, 86, 93, 93, 93, 93, 71, 
	98, 98, 98, 86, 99, 99, 71, 101, 
	100, 100, 100, 100, 71, 85, 85, 85, 
	86, 93, 102, 93, 93, 93, 71, 85, 
	85, 85, 86, 93, 103, 93, 93, 93, 
	71, 85, 85, 85, 86, 93, 104, 93, 
	93, 93, 71, 85, 85, 85, 86, 93, 
	105, 93, 93, 93, 71, 106, 106, 106, 
	86, 93, 93, 93, 93, 71, 107, 107, 
	107, 86, 108, 108, 108, 108, 108, 108, 
	108, 108, 71, 109, 109, 109, 86, 110, 
	110, 110, 110, 110, 110, 110, 110, 71, 
	109, 109, 109, 86, 111, 110, 110, 110, 
	110, 110, 110, 110, 71, 112, 112, 112, 
	111, 112, 112, 112, 112, 112, 112, 112, 
	112, 71, 114, 114, 114, 115, 113, 116, 
	113, 117, 113, 118, 119, 117, 119, 119, 
	119, 113, 121, 122, 120, 121, 122, 123, 
	120, 112, 112, 112, 112, 112, 112, 112, 
	112, 112, 112, 112, 71, 126, 127, 125, 
	126, 127, 128, 125, 130, 129, 131, 131, 
	131, 131, 132, 131, 131, 131, 131, 131, 
	131, 124, 134, 134, 134, 135, 133, 136, 
	133, 137, 133, 138, 139, 137, 139, 139, 
	139, 133, 141, 142, 140, 141, 142, 143, 
	140, 146, 147, 145, 146, 147, 148, 145, 
	150, 149, 151, 144, 152, 144, 153, 144, 
	154, 144, 155, 144, 156, 144, 157, 144, 
	158, 144, 159, 144, 160, 144, 161, 144, 
	162, 163, 161, 144, 164, 144, 165, 144, 
	166, 167, 165, 144, 168, 144, 169, 170, 
	168, 144, 171, 144, 172, 144, 173, 144, 
	174, 144, 175, 176, 174, 144, 179, 180, 
	178, 179, 180, 181, 178, 183, 182, 185, 
	186, 184, 177, 188, 190, 191, 187, 189, 
	189, 189, 177, 188, 191, 187, 189, 189, 
	189, 177, 188, 190, 192, 191, 187, 189, 
	189, 189, 177, 188, 190, 193, 191, 187, 
	189, 189, 189, 177, 188, 190, 194, 191, 
	187, 189, 189, 189, 177, 188, 190, 195, 
	191, 187, 189, 189, 189, 177, 188, 190, 
	196, 191, 187, 189, 189, 189, 177, 188, 
	190, 197, 191, 187, 189, 189, 189, 177, 
	188, 190, 198, 191, 187, 189, 189, 189, 
	177, 199, 199, 199, 190, 189, 189, 189, 
	177, 199, 199, 199, 201, 200, 200, 200, 
	177, 188, 190, 202, 203, 191, 187, 189, 
	189, 189, 177, 188, 190, 204, 191, 187, 
	189, 189, 189, 177, 188, 190, 205, 191, 
	187, 189, 189, 189, 177, 188, 190, 206, 
	191, 187, 189, 189, 189, 177, 188, 190, 
	207, 191, 187, 189, 189, 189, 177, 188, 
	190, 208, 191, 187, 189, 189, 189, 177, 
	188, 190, 209, 191, 187, 189, 189, 189, 
	177, 188, 190, 210, 191, 187, 189, 189, 
	189, 177, 190, 189, 189, 189, 177, 188, 
	190, 211, 191, 187, 189, 189, 189, 177, 
	188, 190, 212, 191, 187, 189, 189, 189, 
	177, 188, 190, 213, 191, 187, 189, 189, 
	189, 177, 188, 190, 210, 191, 187, 189, 
	189, 189, 177, 188, 190, 214, 191, 187, 
	189, 189, 189, 177, 188, 190, 215, 191, 
	187, 189, 189, 189, 177, 188, 190, 216, 
	191, 187, 189, 189, 189, 177, 188, 190, 
	198, 191, 187, 189, 189, 189, 177, 219, 
	220, 221, 218, 219, 220, 218, 219, 220, 
	222, 218, 223, 220, 224, 221, 224, 224, 
	224, 218, 226, 227, 225, 226, 227, 228, 
	225, 230, 229, 231, 217, 232, 217, 233, 
	217, 234, 235, 217, 236, 217, 237, 217, 
	238, 217, 239, 217, 240, 217, 241, 217, 
	242, 217, 243, 217, 244, 217, 245, 217, 
	246, 246, 246, 217, 246, 246, 246, 247, 
	247, 217, 249, 248, 248, 248, 248, 217, 
	250, 217, 251, 217, 252, 217, 253, 217, 
	254, 255, 253, 217, 256, 217, 257, 217, 
	258, 217, 259, 217, 260, 260, 260, 217, 
	261, 261, 261, 262, 262, 262, 262, 262, 
	262, 262, 262, 217, 263, 263, 263, 264, 
	264, 264, 264, 264, 264, 264, 264, 217, 
	263, 263, 263, 265, 264, 264, 264, 264, 
	264, 264, 264, 264, 217, 266, 266, 266, 
	265, 266, 266, 266, 266, 266, 266, 266, 
	266, 217, 268, 268, 268, 269, 267, 270, 
	267, 271, 267, 272, 273, 271, 273, 273, 
	273, 267, 275, 276, 274, 275, 276, 277, 
	274, 266, 266, 266, 266, 266, 266, 266, 
	266, 266, 266, 266, 217, 280, 281, 279, 
	280, 281, 282, 279, 284, 283, 286, 287, 
	285, 278, 289, 291, 292, 288, 290, 290, 
	290, 278, 289, 292, 288, 290, 290, 290, 
	278, 289, 291, 293, 292, 288, 290, 290, 
	290, 278, 289, 291, 294, 292, 288, 290, 
	290, 290, 278, 289, 291, 295, 292, 288, 
	290, 290, 290, 278, 289, 291, 296, 292, 
	288, 290, 290, 290, 278, 289, 291, 297, 
	292, 288, 290, 290, 290, 278, 289, 291, 
	298, 292, 288, 290, 290, 290, 278, 289, 
	291, 299, 292, 288, 290, 290, 290, 278, 
	300, 300, 300, 291, 290, 290, 290, 278, 
	300, 300, 300, 302, 301, 301, 301, 278, 
	289, 291, 303, 304, 292, 288, 290, 290, 
	290, 278, 289, 291, 305, 292, 288, 290, 
	290, 290, 278, 289, 291, 306, 292, 288, 
	290, 290, 290, 278, 289, 291, 307, 292, 
	288, 290, 290, 290, 278, 289, 291, 308, 
	292, 288, 290, 290, 290, 278, 289, 291, 
	309, 292, 288, 290, 290, 290, 278, 289, 
	291, 310, 292, 288, 290, 290, 290, 278, 
	289, 291, 311, 292, 288, 290, 290, 290, 
	278, 291, 290, 290, 290, 278, 289, 291, 
	312, 292, 288, 290, 290, 290, 278, 289, 
	291, 313, 292, 288, 290, 290, 290, 278, 
	289, 291, 314, 292, 288, 290, 290, 290, 
	278, 289, 291, 311, 292, 288, 290, 290, 
	290, 278, 289, 291, 315, 292, 288, 290, 
	290, 290, 278, 289, 291, 316, 292, 288, 
	290, 290, 290, 278, 289, 291, 317, 292, 
	288, 290, 290, 290, 278, 289, 291, 299, 
	292, 288, 290, 290, 290, 278, 320, 321, 
	322, 319, 320, 321, 319, 320, 321, 323, 
	319, 324, 321, 325, 322, 325, 325, 325, 
	319, 327, 328, 326, 327, 328, 329, 326, 
	331, 330, 332, 318, 333, 318, 334, 318, 
	335, 318, 336, 318, 337, 318, 338, 318, 
	339, 318, 340, 318, 341, 318, 342, 343, 
	341, 318, 344, 318, 345, 318, 346, 347, 
	345, 318, 348, 347, 349, 349, 318, 351, 
	350, 350, 350, 350, 318, 352, 318, 353, 
	318, 354, 318, 355, 318, 356, 318, 357, 
	318, 358, 318, 359, 360, 358, 318, 361, 
	360, 362, 362, 318, 364, 363, 363, 363, 
	363, 318, 365, 318, 366, 318, 367, 318, 
	368, 318, 369, 370, 368, 318, 371, 373, 
	370, 372, 372, 318, 375, 376, 375, 375, 
	377, 378, 379, 378, 374, 378, 378, 378, 
	318, 381, 382, 380, 318, 382, 384, 382, 
	382, 385, 373, 383, 372, 372, 318, 384, 
	386, 373, 383, 372, 372, 318, 387, 388, 
	318, 389, 390, 387, 389, 390, 391, 387, 
	371, 386, 373, 370, 372, 372, 318, 392, 
	388, 393, 388, 318, 389, 390, 394, 387, 
	395, 390, 396, 394, 396, 396, 396, 387, 
	398, 399, 397, 398, 399, 400, 397, 402, 
	403, 405, 401, 404, 404, 318, 406, 381, 
	406, 406, 407, 382, 380, 318, 407, 407, 
	407, 408, 408, 408, 318, 409, 409, 409, 
	410, 409, 409, 409, 409, 409, 318, 412, 
	413, 411, 318, 414, 318, 415, 318, 416, 
	318, 417, 318, 418, 318, 419, 318, 420, 
	318, 421, 318, 422, 423, 421, 318, 424, 
	426, 423, 425, 425, 318, 428, 430, 431, 
	429, 427, 429, 429, 429, 318, 433, 423, 
	432, 318, 429, 318, 434, 318, 435, 318, 
	436, 318, 437, 318, 438, 318, 439, 318, 
	440, 318, 441, 318, 442, 318, 443, 318, 
	444, 318, 445, 446, 444, 318, 447, 446, 
	448, 448, 318, 450, 449, 449, 449, 449, 
	318, 451, 318, 452, 318, 453, 318, 454, 
	318, 455, 318, 456, 457, 455, 318, 458, 
	318, 459, 318, 460, 318, 461, 318, 462, 
	318, 463, 318, 464, 318, 465, 318, 466, 
	467, 465, 318, 470, 471, 472, 473, 474, 
	475, 476, 469, 468, 470, 469, 477, 1, 
	5, 478, 479, 478, 480, 478, 481, 478, 
	482, 478, 483, 478, 486, 487, 489, 490, 
	491, 485, 488, 488, 484, 486, 485, 492, 
	494, 83, 493, 85, 85, 85, 86, 93, 
	93, 93, 93, 493, 85, 85, 85, 86, 
	93, 495, 93, 93, 93, 493, 85, 85, 
	85, 86, 93, 496, 93, 93, 93, 493, 
	114, 114, 114, 115, 497, 498, 500, 499, 
	503, 504, 506, 502, 505, 505, 501, 503, 
	502, 507, 125, 129, 508, 131, 131, 131, 
	131, 131, 131, 131, 131, 131, 131, 508, 
	134, 134, 134, 135, 509, 510, 512, 511, 
	515, 516, 517, 518, 519, 520, 521, 522, 
	514, 513, 515, 514, 523, 145, 149, 524, 
	525, 524, 526, 524, 527, 524, 528, 524, 
	529, 524, 531, 530, 534, 535, 537, 538, 
	533, 536, 536, 536, 532, 534, 533, 539, 
	178, 182, 540, 188, 190, 191, 187, 189, 
	189, 189, 540, 188, 190, 541, 542, 191, 
	187, 189, 189, 189, 540, 544, 543, 547, 
	548, 549, 550, 551, 552, 553, 546, 545, 
	547, 546, 554, 556, 229, 555, 557, 555, 
	558, 555, 559, 555, 560, 555, 268, 268, 
	268, 269, 561, 562, 564, 563, 567, 568, 
	570, 571, 566, 569, 569, 569, 565, 567, 
	566, 572, 279, 283, 573, 289, 291, 292, 
	288, 290, 290, 290, 573, 289, 291, 574, 
	575, 292, 288, 290, 290, 290, 573, 577, 
	576, 580, 581, 582, 583, 584, 585, 586, 
	587, 588, 589, 579, 578, 580, 579, 590, 
	592, 330, 591, 593, 591, 594, 591, 597, 
	596, 595, 598, 599, 591, 602, 601, 600, 
	604, 603, 605, 591, 607, 606, 608, 591, 
	611, 610, 609, 612, 591, 613, 591, 615, 
	614, 0
};

static const short _eo_tokenizer_trans_targs[] = {
	325, 0, 0, 1, 325, 2, 325, 4, 
	5, 6, 7, 8, 9, 10, 10, 11, 
	12, 13, 12, 14, 11, 20, 325, 12, 
	12, 325, 13, 14, 15, 16, 12, 12, 
	325, 17, 17, 15, 18, 16, 19, 17, 
	17, 18, 18, 22, 23, 24, 10, 26, 
	27, 28, 29, 30, 31, 32, 10, 34, 
	35, 36, 10, 38, 39, 40, 41, 42, 
	41, 43, 42, 43, 44, 45, 325, 333, 
	47, 47, 48, 49, 333, 49, 50, 50, 
	50, 51, 333, 52, 333, 53, 54, 55, 
	56, 55, 56, 56, 333, 57, 59, 60, 
	61, 62, 63, 64, 64, 333, 66, 67, 
	68, 69, 70, 71, 80, 72, 73, 339, 
	73, 333, 74, 75, 76, 77, 77, 78, 
	78, 78, 79, 340, 342, 81, 81, 82, 
	342, 83, 342, 84, 346, 342, 85, 86, 
	87, 88, 88, 89, 89, 89, 90, 347, 
	349, 91, 91, 92, 349, 93, 349, 95, 
	96, 97, 98, 99, 100, 101, 102, 103, 
	349, 105, 105, 349, 107, 108, 108, 349, 
	110, 110, 349, 112, 113, 114, 115, 115, 
	349, 358, 116, 116, 117, 358, 118, 358, 
	119, 119, 358, 119, 119, 120, 121, 358, 
	123, 124, 125, 126, 127, 128, 129, 130, 
	120, 131, 132, 140, 133, 134, 135, 136, 
	137, 138, 139, 141, 142, 143, 145, 146, 
	147, 364, 149, 149, 150, 151, 364, 151, 
	152, 152, 152, 153, 364, 154, 364, 156, 
	157, 158, 364, 159, 160, 161, 162, 163, 
	164, 364, 166, 167, 168, 169, 170, 171, 
	171, 364, 173, 174, 175, 176, 176, 364, 
	178, 179, 180, 181, 182, 183, 192, 184, 
	185, 371, 185, 364, 186, 187, 188, 189, 
	189, 190, 190, 190, 191, 372, 374, 193, 
	193, 194, 374, 195, 374, 196, 196, 374, 
	196, 196, 197, 198, 374, 200, 201, 202, 
	203, 204, 205, 206, 207, 197, 208, 209, 
	217, 210, 211, 212, 213, 214, 215, 216, 
	218, 219, 220, 222, 223, 224, 380, 226, 
	226, 227, 228, 380, 228, 229, 229, 229, 
	230, 380, 231, 380, 233, 234, 235, 236, 
	237, 238, 239, 240, 241, 242, 242, 380, 
	244, 245, 245, 246, 246, 247, 247, 385, 
	249, 250, 251, 252, 253, 254, 255, 255, 
	256, 256, 257, 257, 387, 259, 260, 261, 
	262, 262, 263, 263, 264, 388, 265, 279, 
	265, 280, 264, 266, 265, 265, 266, 267, 
	267, 273, 268, 269, 272, 269, 270, 271, 
	271, 274, 275, 275, 276, 276, 276, 277, 
	278, 267, 267, 268, 264, 388, 279, 280, 
	281, 281, 282, 265, 265, 266, 284, 285, 
	286, 287, 288, 289, 290, 291, 291, 292, 
	292, 293, 390, 294, 294, 293, 295, 292, 
	294, 294, 297, 298, 299, 300, 301, 302, 
	303, 304, 305, 306, 307, 307, 308, 308, 
	309, 309, 392, 311, 312, 313, 314, 315, 
	315, 380, 317, 318, 319, 320, 321, 322, 
	323, 324, 324, 380, 325, 326, 326, 327, 
	328, 329, 330, 331, 332, 325, 325, 3, 
	21, 25, 33, 37, 333, 334, 334, 335, 
	336, 337, 338, 341, 333, 333, 46, 58, 
	65, 333, 333, 333, 333, 342, 343, 343, 
	344, 345, 348, 342, 342, 342, 342, 342, 
	342, 349, 350, 350, 351, 352, 353, 354, 
	355, 356, 357, 349, 349, 94, 104, 106, 
	109, 111, 349, 349, 358, 359, 359, 360, 
	361, 362, 363, 358, 358, 122, 144, 358, 
	358, 364, 365, 365, 366, 367, 368, 369, 
	370, 373, 364, 364, 148, 155, 165, 172, 
	177, 364, 364, 364, 364, 374, 375, 375, 
	376, 377, 378, 379, 374, 374, 199, 221, 
	374, 374, 380, 381, 381, 382, 383, 384, 
	386, 389, 391, 393, 394, 395, 380, 380, 
	225, 232, 243, 380, 385, 385, 248, 258, 
	380, 387, 387, 380, 380, 283, 380, 380, 
	296, 380, 392, 392, 310, 316, 380, 380
};

static const short _eo_tokenizer_trans_actions[] = {
	209, 0, 1, 0, 199, 0, 232, 0, 
	0, 0, 0, 0, 0, 33, 0, 5, 
	39, 39, 304, 39, 0, 0, 307, 0, 
	1, 201, 0, 0, 0, 5, 15, 280, 
	283, 13, 277, 13, 13, 0, 0, 0, 
	1, 0, 1, 0, 0, 0, 31, 0, 
	0, 0, 0, 0, 0, 0, 37, 0, 
	0, 0, 35, 0, 0, 0, 5, 41, 
	0, 41, 0, 0, 5, 0, 310, 67, 
	0, 1, 0, 0, 51, 1, 5, 0, 
	1, 0, 49, 0, 211, 0, 0, 7, 
	241, 0, 5, 0, 244, 0, 0, 0, 
	0, 0, 0, 5, 0, 238, 0, 0, 
	0, 0, 0, 5, 5, 5, 5, 319, 
	0, 65, 0, 0, 0, 0, 1, 5, 
	0, 1, 0, 0, 85, 0, 1, 0, 
	69, 0, 214, 0, 322, 83, 0, 0, 
	0, 0, 1, 5, 0, 1, 0, 0, 
	107, 0, 1, 0, 87, 0, 217, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	250, 0, 1, 89, 0, 0, 1, 93, 
	0, 1, 91, 0, 0, 0, 0, 1, 
	95, 123, 0, 1, 0, 109, 0, 220, 
	0, 1, 111, 9, 253, 0, 0, 256, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	328, 328, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 145, 0, 1, 0, 0, 127, 1, 
	5, 0, 1, 0, 125, 0, 223, 0, 
	0, 0, 265, 0, 0, 0, 0, 0, 
	0, 268, 0, 0, 0, 0, 0, 5, 
	0, 262, 0, 0, 0, 0, 1, 129, 
	0, 0, 0, 0, 0, 5, 5, 5, 
	5, 325, 0, 143, 0, 0, 0, 0, 
	1, 5, 0, 1, 0, 0, 161, 0, 
	1, 0, 147, 0, 226, 0, 1, 149, 
	11, 271, 0, 0, 274, 0, 0, 0, 
	0, 0, 0, 0, 0, 332, 332, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 197, 0, 
	1, 0, 0, 165, 1, 5, 0, 1, 
	0, 163, 0, 229, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 171, 
	0, 0, 1, 0, 1, 5, 0, 27, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	0, 1, 5, 0, 25, 0, 0, 0, 
	0, 1, 0, 1, 5, 0, 17, 17, 
	286, 17, 0, 17, 0, 1, 0, 0, 
	1, 3, 3, 0, 0, 1, 0, 0, 
	1, 0, 0, 1, 5, 0, 1, 0, 
	0, 21, 292, 295, 298, 21, 0, 0, 
	5, 0, 0, 19, 289, 19, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 0, 
	1, 5, 0, 29, 301, 0, 0, 29, 
	0, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 0, 1, 
	5, 0, 23, 0, 0, 0, 0, 0, 
	1, 175, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 173, 203, 0, 1, 313, 
	47, 47, 47, 47, 47, 205, 207, 0, 
	0, 0, 0, 0, 55, 0, 1, 313, 
	316, 316, 316, 0, 57, 63, 0, 0, 
	0, 59, 235, 61, 53, 73, 0, 1, 
	313, 316, 0, 75, 81, 77, 247, 79, 
	71, 99, 0, 1, 313, 47, 47, 47, 
	47, 47, 0, 101, 105, 0, 0, 0, 
	0, 0, 103, 97, 115, 0, 1, 313, 
	316, 316, 0, 117, 121, 0, 0, 119, 
	113, 133, 0, 1, 313, 47, 47, 47, 
	47, 0, 135, 141, 0, 0, 0, 0, 
	0, 137, 259, 139, 131, 153, 0, 1, 
	313, 316, 316, 0, 155, 159, 0, 0, 
	157, 151, 179, 0, 1, 313, 47, 47, 
	47, 47, 47, 47, 47, 0, 181, 195, 
	0, 0, 0, 187, 0, 1, 0, 0, 
	185, 0, 1, 191, 169, 0, 189, 167, 
	0, 183, 0, 1, 0, 0, 193, 177
};

static const short _eo_tokenizer_to_state_actions[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 43, 0, 0, 
	0, 0, 0, 0, 0, 43, 0, 0, 
	0, 0, 0, 0, 0, 0, 43, 0, 
	0, 0, 0, 0, 0, 43, 0, 0, 
	0, 0, 0, 0, 0, 0, 43, 0, 
	0, 0, 0, 0, 43, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 43, 0, 
	0, 0, 0, 0, 43, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0
};

static const short _eo_tokenizer_from_state_actions[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 45, 0, 0, 
	0, 0, 0, 0, 0, 45, 0, 0, 
	0, 0, 0, 0, 0, 0, 45, 0, 
	0, 0, 0, 0, 0, 45, 0, 0, 
	0, 0, 0, 0, 0, 0, 45, 0, 
	0, 0, 0, 0, 45, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 45, 0, 
	0, 0, 0, 0, 45, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0
};

static const short _eo_tokenizer_eof_trans[] = {
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 72, 72, 
	72, 72, 72, 72, 72, 72, 72, 72, 
	72, 72, 72, 72, 72, 72, 72, 72, 
	72, 72, 72, 72, 72, 72, 72, 72, 
	72, 72, 114, 114, 114, 114, 114, 114, 
	72, 125, 125, 125, 125, 134, 134, 134, 
	134, 134, 134, 145, 145, 145, 145, 145, 
	145, 145, 145, 145, 145, 145, 145, 145, 
	145, 145, 145, 145, 145, 145, 145, 145, 
	145, 145, 145, 145, 178, 178, 178, 178, 
	178, 178, 178, 178, 178, 178, 178, 178, 
	178, 178, 178, 178, 178, 178, 178, 178, 
	178, 178, 178, 178, 178, 178, 178, 178, 
	178, 178, 178, 178, 218, 218, 218, 218, 
	218, 218, 218, 218, 218, 218, 218, 218, 
	218, 218, 218, 218, 218, 218, 218, 218, 
	218, 218, 218, 218, 218, 218, 218, 218, 
	218, 218, 218, 218, 218, 218, 218, 218, 
	218, 218, 268, 268, 268, 268, 268, 268, 
	218, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 319, 319, 319, 
	319, 319, 319, 319, 319, 0, 478, 479, 
	479, 479, 479, 479, 479, 0, 493, 494, 
	494, 494, 494, 498, 499, 500, 0, 508, 
	509, 509, 510, 511, 512, 0, 524, 525, 
	525, 525, 525, 525, 525, 531, 0, 540, 
	541, 541, 541, 544, 0, 555, 556, 556, 
	556, 556, 556, 562, 563, 564, 0, 573, 
	574, 574, 574, 577, 0, 591, 592, 592, 
	592, 596, 592, 601, 604, 592, 607, 592, 
	610, 592, 592, 615
};

static const int eo_tokenizer_start = 325;
static const int eo_tokenizer_first_final = 325;
static const int eo_tokenizer_error = -1;

static const int eo_tokenizer_en_tokenize_accessor = 333;
static const int eo_tokenizer_en_tokenize_params = 342;
static const int eo_tokenizer_en_tokenize_property = 349;
static const int eo_tokenizer_en_tokenize_properties = 358;
static const int eo_tokenizer_en_tokenize_method = 364;
static const int eo_tokenizer_en_tokenize_methods = 374;
static const int eo_tokenizer_en_tokenize_class = 380;
static const int eo_tokenizer_en_main = 325;


#line 1014 "src/lib/eolian/eo_lexer.rl"


Eina_Bool
eo_tokenizer_walk(Eo_Tokenizer *toknz, const char *source)
{
   INF("tokenize %s...", source);
   toknz->source = eina_stringshare_add(source);

   FILE *stream;
   Eina_Bool ret = EINA_TRUE;

   int done = 0;
   int have = 0;
   int offset = 0;

   stream = fopen(toknz->source, "rb");
   if (!stream)
     {
        ERR("unable to read in %s", toknz->source);
        return EINA_FALSE;
     }

   
#line 1482 "src/lib/eolian/eo_lexer.c"
	{
	 toknz->cs = eo_tokenizer_start;
	 toknz->ts = 0;
	 toknz->te = 0;
	 toknz->act = 0;
	}

#line 1037 "src/lib/eolian/eo_lexer.rl"

   while (!done)
     {
        int len;
        int space;

        toknz->p = toknz->buf + have;
        space = BUFSIZE - have;

        if (space == 0)
          {
             fclose(stream);
             ABORT(toknz, "out of buffer space");
          }

        len = fread(toknz->p, 1, space, stream);
        if (len == 0) break;
        toknz->pe = toknz->p + len;

        if (len < space)
          {
             toknz->eof = toknz->pe;
             done = 1;
          }

        
#line 1517 "src/lib/eolian/eo_lexer.c"
	{
	int _klen;
	unsigned int _trans;
	const char *_acts;
	unsigned int _nacts;
	const char *_keys;

	if ( ( toknz->p) == ( toknz->pe) )
		goto _test_eof;
_resume:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_from_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 38:
#line 1 "NONE"
	{ toknz->ts = ( toknz->p);}
	break;
#line 1536 "src/lib/eolian/eo_lexer.c"
		}
	}

	_keys = _eo_tokenizer_trans_keys + _eo_tokenizer_key_offsets[ toknz->cs];
	_trans = _eo_tokenizer_index_offsets[ toknz->cs];

	_klen = _eo_tokenizer_single_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + _klen - 1;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + ((_upper-_lower) >> 1);
			if ( (*( toknz->p)) < *_mid )
				_upper = _mid - 1;
			else if ( (*( toknz->p)) > *_mid )
				_lower = _mid + 1;
			else {
				_trans += (unsigned int)(_mid - _keys);
				goto _match;
			}
		}
		_keys += _klen;
		_trans += _klen;
	}

	_klen = _eo_tokenizer_range_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + (_klen<<1) - 2;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
			if ( (*( toknz->p)) < _mid[0] )
				_upper = _mid - 2;
			else if ( (*( toknz->p)) > _mid[1] )
				_lower = _mid + 2;
			else {
				_trans += (unsigned int)((_mid - _keys)>>1);
				goto _match;
			}
		}
		_trans += _klen;
	}

_match:
	_trans = _eo_tokenizer_indicies[_trans];
_eof_trans:
	 toknz->cs = _eo_tokenizer_trans_targs[_trans];

	if ( _eo_tokenizer_trans_actions[_trans] == 0 )
		goto _again;

	_acts = _eo_tokenizer_actions + _eo_tokenizer_trans_actions[_trans];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 )
	{
		switch ( *_acts++ )
		{
	case 0:
#line 377 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->current_line += 1;
      DBG("inc[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 1:
#line 382 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->saved.line = toknz->current_line;
      DBG("save line[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 2:
#line 387 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->saved.tok = ( toknz->p);
      DBG("save token[%d] %p %c", toknz->cs, ( toknz->p), *( toknz->p));
   }
	break;
	case 3:
#line 392 "src/lib/eolian/eo_lexer.rl"
	{
      DBG("move ts %d chars forward", (int)(( toknz->p) - toknz->ts));
      toknz->ts = ( toknz->p);
   }
	break;
	case 4:
#line 472 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->ret != NULL)
        ABORT(toknz, "accessor has already a return type");
      toknz->tmp.accessor->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 5:
#line 479 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (!toknz->tmp.accessor->ret) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.accessor->ret->comment != NULL)
        ABORT(toknz, "accessor return type has already a comment");
      toknz->tmp.accessor->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.accessor->ret->comment);
   }
	break;
	case 6:
#line 488 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      toknz->tmp.accessor->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 7:
#line 502 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.accessor_param = _eo_tokenizer_accessor_param_get(toknz, ( toknz->p));
   }
	break;
	case 8:
#line 506 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor_param)
         ABORT(toknz, "No accessor param!!!");
      toknz->tmp.accessor_param->attrs = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.accessor->params =
         eina_list_append(toknz->tmp.accessor->params, toknz->tmp.accessor_param);
      toknz->tmp.accessor_param = NULL;
   }
	break;
	case 9:
#line 535 "src/lib/eolian/eo_lexer.rl"
	{
      const char *c = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      if (toknz->tmp.param == NULL)
        ABORT(toknz, "no parameter set to associate this comment to: %s", c);
      toknz->tmp.param->comment = c;
      toknz->tmp.param = NULL;
   }
	break;
	case 10:
#line 543 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.param = _eo_tokenizer_param_get(toknz, ( toknz->p));
      if (toknz->tmp.params)
        *(toknz->tmp.params) = eina_list_append(*(toknz->tmp.params), toknz->tmp.param);
      else
        ABORT(toknz, "got a param but there is no property nor method waiting for it");
      INF("        %s : %s", toknz->tmp.param->name, toknz->tmp.param->type);
   }
	break;
	case 11:
#line 617 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      toknz->tmp.prop->is_ctor = EINA_TRUE;
      INF("        constructor");
   }
	break;
	case 12:
#line 651 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.prop != NULL)
        ABORT(toknz, "there is a pending property definition %s", toknz->tmp.prop->name);
      toknz->tmp.prop = _eo_tokenizer_property_get(toknz, ( toknz->p));
   }
	break;
	case 13:
#line 657 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.fscope = _eo_tokenizer_scope_get(toknz, ( toknz->p));
   }
	break;
	case 14:
#line 695 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret != NULL)
        ABORT(toknz, "method '%s' has already a return type", toknz->tmp.meth->name);
      toknz->tmp.meth->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 15:
#line 702 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret == NULL) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.meth->ret->comment != NULL)
        ABORT(toknz, "method '%s' return type has already a comment", toknz->tmp.meth->name);
      toknz->tmp.meth->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.meth->ret->comment);
   }
	break;
	case 16:
#line 711 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 17:
#line 716 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->obj_const = EINA_TRUE;
      INF("        obj const");
   }
	break;
	case 18:
#line 722 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->is_ctor = EINA_TRUE;
      INF("        constructor");
   }
	break;
	case 19:
#line 783 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.meth != NULL)
        ABORT(toknz, "there is a pending method definition %s", toknz->tmp.meth->name);
      toknz->tmp.meth = _eo_tokenizer_method_get(toknz, ( toknz->p));
   }
	break;
	case 20:
#line 789 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.fscope = _eo_tokenizer_scope_get(toknz, ( toknz->p));
   }
	break;
	case 21:
#line 819 "src/lib/eolian/eo_lexer.rl"
	{
      const char *base = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.str_items = eina_list_append(toknz->tmp.str_items, base);
   }
	break;
	case 22:
#line 824 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.kls->inherits = toknz->tmp.str_items;
      toknz->tmp.str_items = NULL;
   }
	break;
	case 23:
#line 868 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.event = _eo_tokenizer_event_get(toknz, ( toknz->p));
      toknz->tmp.kls->events = eina_list_append(toknz->tmp.kls->events, toknz->tmp.event);
   }
	break;
	case 24:
#line 874 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.event) ABORT(toknz, "No event!!!");
      if (toknz->tmp.event->type != NULL)
        ABORT(toknz, "event %s has already a type %s", toknz->tmp.event->name, toknz->tmp.event->type);
      toknz->tmp.event->type = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
   }
	break;
	case 25:
#line 881 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.event) ABORT(toknz, "No event!!!");
      if (toknz->tmp.event->comment != NULL)
        ABORT(toknz, "event %s has already a comment", toknz->tmp.event->name);
      toknz->tmp.event->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      toknz->tmp.event = NULL;
   }
	break;
	case 26:
#line 889 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->legacy_prefix != NULL)
        ABORT(toknz, "A legacy prefix has already been given");
      toknz->tmp.kls->legacy_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 27:
#line 898 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->eo_prefix != NULL)
        ABORT(toknz, "An Eo prefix has already been given");
      toknz->tmp.kls->eo_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 28:
#line 907 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->data_type != NULL)
        ABORT(toknz, "A data type has already been given");
      toknz->tmp.kls->data_type = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 29:
#line 920 "src/lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
        toknz->tmp.impl = _eo_tokenizer_implement_get(toknz, ( toknz->p));
        toknz->tmp.kls->implements = eina_list_append(toknz->tmp.kls->implements, toknz->tmp.impl);
   }
	break;
	case 30:
#line 964 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_REGULAR;
   }
	break;
	case 31:
#line 967 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_ABSTRACT;
   }
	break;
	case 32:
#line 970 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_MIXIN;
   }
	break;
	case 33:
#line 973 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_INTERFACE;
   }
	break;
	case 34:
#line 977 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.kls != NULL)
        ABORT(toknz, "there is a pending class definition %s", toknz->tmp.kls->name);
      toknz->tmp.kls = _eo_tokenizer_class_get(toknz, ( toknz->p));
      toknz->tmp.kls->type = toknz->tmp.kls_type;
   }
	break;
	case 35:
#line 990 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.typedef_alias = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 36:
#line 994 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.typedef_alias == NULL)
        ABORT(toknz, "No typedef");
      toknz->tmp.type_def = _eo_tokenizer_type_get(toknz, ( toknz->p));
      toknz->tmp.type_def->alias = toknz->tmp.typedef_alias;
      toknz->typedefs = eina_list_append(toknz->typedefs, toknz->tmp.type_def);
   }
	break;
	case 39:
#line 1 "NONE"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 40:
#line 464 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->comment != NULL)
        ABORT(toknz, "accessor has already a comment");
      toknz->tmp.accessor->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.accessor->comment);
   }}
	break;
	case 41:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 42:
#line 527 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 43:
#line 528 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 44:
#line 493 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 349; goto _again;}
   }}
	break;
	case 45:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 46:
#line 523 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 47:
#line 526 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 48:
#line 493 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 349; goto _again;}
   }}
	break;
	case 49:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 50:
#line 526 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 51:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 52:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 53:
#line 552 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 349; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 364; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 54:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 55:
#line 568 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 56:
#line 570 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 57:
#line 552 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 349; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 364; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 58:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 59:
#line 570 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 60:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 61:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 62:
#line 577 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      get {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, GETTER);
      toknz->current_nesting++;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 63:
#line 584 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      set {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, SETTER);
      toknz->current_nesting++;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 64:
#line 591 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      keys {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->keys);
      { toknz->cs = 342; goto _again;}
   }}
	break;
	case 65:
#line 598 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      values {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->values);
      { toknz->cs = 342; goto _again;}
   }}
	break;
	case 66:
#line 637 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 67:
#line 605 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 358; goto _again;}
   }}
	break;
	case 68:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 69:
#line 631 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 70:
#line 605 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 358; goto _again;}
   }}
	break;
	case 71:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 72:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 73:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 74:
#line 644 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      INF("    %s {", toknz->tmp.prop->name);
      toknz->current_nesting++;
      { toknz->cs = 349; goto _again;}
   }}
	break;
	case 75:
#line 661 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 76:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 77:
#line 670 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 78:
#line 661 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 79:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 80:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 81:
#line 679 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->comment != NULL)
        ABORT(toknz, "method has already a comment");
      toknz->tmp.meth->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.meth->comment);
   }}
	break;
	case 82:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 83:
#line 687 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("      params {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.meth->params);
      { toknz->cs = 342; goto _again;}
   }}
	break;
	case 84:
#line 767 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 85:
#line 768 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 86:
#line 769 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 87:
#line 728 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 88:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 89:
#line 762 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 90:
#line 766 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 91:
#line 728 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 92:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 93:
#line 766 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 94:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 95:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 96:
#line 776 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    %s {", toknz->tmp.meth->name);
      toknz->current_nesting++;
      { toknz->cs = 364; goto _again;}
   }}
	break;
	case 97:
#line 793 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 98:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 99:
#line 803 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 100:
#line 793 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 101:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 102:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 103:
#line 812 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->comment != NULL)
        ABORT(toknz, "class %s has already a comment", toknz->tmp.kls->name);
      toknz->tmp.kls->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
   }}
	break;
	case 104:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 105:
#line 830 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 106:
#line 833 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 107:
#line 836 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  constructors {");
      toknz->current_methods_type = METH_CONSTRUCTOR;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting++;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 108:
#line 844 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  properties {");
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting++;
      { toknz->cs = 358; goto _again;}
   }}
	break;
	case 109:
#line 851 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  begin methods");
      toknz->current_methods_type = METH_REGULAR;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting++;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 110:
#line 859 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 111:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 112:
#line 940 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 113:
#line 943 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 114:
#line 944 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 115:
#line 945 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 116:
#line 830 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 117:
#line 833 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 118:
#line 859 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 119:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 120:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 121:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 122:
#line 957 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("begin class: %s", toknz->tmp.kls->name);
      toknz->current_nesting++;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 123:
#line 1010 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 124:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 125:
#line 1007 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 126:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 127:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
#line 2845 "src/lib/eolian/eo_lexer.c"
		}
	}

_again:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_to_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 37:
#line 1 "NONE"
	{ toknz->ts = 0;}
	break;
#line 2858 "src/lib/eolian/eo_lexer.c"
		}
	}

	if ( ++( toknz->p) != ( toknz->pe) )
		goto _resume;
	_test_eof: {}
	if ( ( toknz->p) == ( toknz->eof) )
	{
	if ( _eo_tokenizer_eof_trans[ toknz->cs] > 0 ) {
		_trans = _eo_tokenizer_eof_trans[ toknz->cs] - 1;
		goto _eof_trans;
	}
	}

	_out: {}
	}

#line 1063 "src/lib/eolian/eo_lexer.rl"

        if ( toknz->cs == 
#line 2879 "src/lib/eolian/eo_lexer.c"
-1
#line 1064 "src/lib/eolian/eo_lexer.rl"
 )
          {
             ERR("%s: wrong termination", source);
             ret = EINA_FALSE;
             break;
          }

        if ( toknz->ts == 0 )
          have = 0;
        else
          {
             DBG("move data and pointers before buffer feed");
             have = toknz->pe - toknz->ts;
             offset = toknz->ts - toknz->buf;
             memmove(toknz->buf, toknz->ts, have);
             toknz->te -= offset;
             toknz->ts = toknz->buf;
          }

        if (toknz->saved.tok != NULL)
          {
             if ((have == 0) || ((toknz->saved.tok - offset) < toknz->buf))
               {
                  WRN("reset lost saved token %p", toknz->saved.tok);
                  toknz->saved.tok = NULL;
               }
             else
               toknz->saved.tok -= offset;
          }
     }

   fclose(stream);

   return ret;
}

static Eina_Bool
eo_tokenizer_mem_walk(Eo_Tokenizer *toknz, const char *source, char *buffer, unsigned int len)
{
   INF("tokenize %s...", source);
   toknz->source = eina_stringshare_add(source);

   Eina_Bool ret = EINA_TRUE;

   
#line 2927 "src/lib/eolian/eo_lexer.c"
	{
	 toknz->cs = eo_tokenizer_start;
	 toknz->ts = 0;
	 toknz->te = 0;
	 toknz->act = 0;
	}

#line 1109 "src/lib/eolian/eo_lexer.rl"

   toknz->p = buffer;

   toknz->pe = toknz->p + len;

   toknz->eof = toknz->pe;

   
#line 2944 "src/lib/eolian/eo_lexer.c"
	{
	int _klen;
	unsigned int _trans;
	const char *_acts;
	unsigned int _nacts;
	const char *_keys;

	if ( ( toknz->p) == ( toknz->pe) )
		goto _test_eof;
_resume:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_from_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 38:
#line 1 "NONE"
	{ toknz->ts = ( toknz->p);}
	break;
#line 2963 "src/lib/eolian/eo_lexer.c"
		}
	}

	_keys = _eo_tokenizer_trans_keys + _eo_tokenizer_key_offsets[ toknz->cs];
	_trans = _eo_tokenizer_index_offsets[ toknz->cs];

	_klen = _eo_tokenizer_single_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + _klen - 1;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + ((_upper-_lower) >> 1);
			if ( (*( toknz->p)) < *_mid )
				_upper = _mid - 1;
			else if ( (*( toknz->p)) > *_mid )
				_lower = _mid + 1;
			else {
				_trans += (unsigned int)(_mid - _keys);
				goto _match;
			}
		}
		_keys += _klen;
		_trans += _klen;
	}

	_klen = _eo_tokenizer_range_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + (_klen<<1) - 2;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
			if ( (*( toknz->p)) < _mid[0] )
				_upper = _mid - 2;
			else if ( (*( toknz->p)) > _mid[1] )
				_lower = _mid + 2;
			else {
				_trans += (unsigned int)((_mid - _keys)>>1);
				goto _match;
			}
		}
		_trans += _klen;
	}

_match:
	_trans = _eo_tokenizer_indicies[_trans];
_eof_trans:
	 toknz->cs = _eo_tokenizer_trans_targs[_trans];

	if ( _eo_tokenizer_trans_actions[_trans] == 0 )
		goto _again;

	_acts = _eo_tokenizer_actions + _eo_tokenizer_trans_actions[_trans];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 )
	{
		switch ( *_acts++ )
		{
	case 0:
#line 377 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->current_line += 1;
      DBG("inc[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 1:
#line 382 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->saved.line = toknz->current_line;
      DBG("save line[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 2:
#line 387 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->saved.tok = ( toknz->p);
      DBG("save token[%d] %p %c", toknz->cs, ( toknz->p), *( toknz->p));
   }
	break;
	case 3:
#line 392 "src/lib/eolian/eo_lexer.rl"
	{
      DBG("move ts %d chars forward", (int)(( toknz->p) - toknz->ts));
      toknz->ts = ( toknz->p);
   }
	break;
	case 4:
#line 472 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->ret != NULL)
        ABORT(toknz, "accessor has already a return type");
      toknz->tmp.accessor->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 5:
#line 479 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (!toknz->tmp.accessor->ret) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.accessor->ret->comment != NULL)
        ABORT(toknz, "accessor return type has already a comment");
      toknz->tmp.accessor->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.accessor->ret->comment);
   }
	break;
	case 6:
#line 488 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      toknz->tmp.accessor->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 7:
#line 502 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.accessor_param = _eo_tokenizer_accessor_param_get(toknz, ( toknz->p));
   }
	break;
	case 8:
#line 506 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor_param)
         ABORT(toknz, "No accessor param!!!");
      toknz->tmp.accessor_param->attrs = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.accessor->params =
         eina_list_append(toknz->tmp.accessor->params, toknz->tmp.accessor_param);
      toknz->tmp.accessor_param = NULL;
   }
	break;
	case 9:
#line 535 "src/lib/eolian/eo_lexer.rl"
	{
      const char *c = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      if (toknz->tmp.param == NULL)
        ABORT(toknz, "no parameter set to associate this comment to: %s", c);
      toknz->tmp.param->comment = c;
      toknz->tmp.param = NULL;
   }
	break;
	case 10:
#line 543 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.param = _eo_tokenizer_param_get(toknz, ( toknz->p));
      if (toknz->tmp.params)
        *(toknz->tmp.params) = eina_list_append(*(toknz->tmp.params), toknz->tmp.param);
      else
        ABORT(toknz, "got a param but there is no property nor method waiting for it");
      INF("        %s : %s", toknz->tmp.param->name, toknz->tmp.param->type);
   }
	break;
	case 11:
#line 617 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      toknz->tmp.prop->is_ctor = EINA_TRUE;
      INF("        constructor");
   }
	break;
	case 12:
#line 651 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.prop != NULL)
        ABORT(toknz, "there is a pending property definition %s", toknz->tmp.prop->name);
      toknz->tmp.prop = _eo_tokenizer_property_get(toknz, ( toknz->p));
   }
	break;
	case 13:
#line 657 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.fscope = _eo_tokenizer_scope_get(toknz, ( toknz->p));
   }
	break;
	case 14:
#line 695 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret != NULL)
        ABORT(toknz, "method '%s' has already a return type", toknz->tmp.meth->name);
      toknz->tmp.meth->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 15:
#line 702 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret == NULL) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.meth->ret->comment != NULL)
        ABORT(toknz, "method '%s' return type has already a comment", toknz->tmp.meth->name);
      toknz->tmp.meth->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.meth->ret->comment);
   }
	break;
	case 16:
#line 711 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 17:
#line 716 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->obj_const = EINA_TRUE;
      INF("        obj const");
   }
	break;
	case 18:
#line 722 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->is_ctor = EINA_TRUE;
      INF("        constructor");
   }
	break;
	case 19:
#line 783 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.meth != NULL)
        ABORT(toknz, "there is a pending method definition %s", toknz->tmp.meth->name);
      toknz->tmp.meth = _eo_tokenizer_method_get(toknz, ( toknz->p));
   }
	break;
	case 20:
#line 789 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.fscope = _eo_tokenizer_scope_get(toknz, ( toknz->p));
   }
	break;
	case 21:
#line 819 "src/lib/eolian/eo_lexer.rl"
	{
      const char *base = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.str_items = eina_list_append(toknz->tmp.str_items, base);
   }
	break;
	case 22:
#line 824 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.kls->inherits = toknz->tmp.str_items;
      toknz->tmp.str_items = NULL;
   }
	break;
	case 23:
#line 868 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.event = _eo_tokenizer_event_get(toknz, ( toknz->p));
      toknz->tmp.kls->events = eina_list_append(toknz->tmp.kls->events, toknz->tmp.event);
   }
	break;
	case 24:
#line 874 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.event) ABORT(toknz, "No event!!!");
      if (toknz->tmp.event->type != NULL)
        ABORT(toknz, "event %s has already a type %s", toknz->tmp.event->name, toknz->tmp.event->type);
      toknz->tmp.event->type = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
   }
	break;
	case 25:
#line 881 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.event) ABORT(toknz, "No event!!!");
      if (toknz->tmp.event->comment != NULL)
        ABORT(toknz, "event %s has already a comment", toknz->tmp.event->name);
      toknz->tmp.event->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      toknz->tmp.event = NULL;
   }
	break;
	case 26:
#line 889 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->legacy_prefix != NULL)
        ABORT(toknz, "A legacy prefix has already been given");
      toknz->tmp.kls->legacy_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 27:
#line 898 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->eo_prefix != NULL)
        ABORT(toknz, "An Eo prefix has already been given");
      toknz->tmp.kls->eo_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 28:
#line 907 "src/lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->data_type != NULL)
        ABORT(toknz, "A data type has already been given");
      toknz->tmp.kls->data_type = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 29:
#line 920 "src/lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
        toknz->tmp.impl = _eo_tokenizer_implement_get(toknz, ( toknz->p));
        toknz->tmp.kls->implements = eina_list_append(toknz->tmp.kls->implements, toknz->tmp.impl);
   }
	break;
	case 30:
#line 964 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_REGULAR;
   }
	break;
	case 31:
#line 967 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_ABSTRACT;
   }
	break;
	case 32:
#line 970 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_MIXIN;
   }
	break;
	case 33:
#line 973 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_INTERFACE;
   }
	break;
	case 34:
#line 977 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.kls != NULL)
        ABORT(toknz, "there is a pending class definition %s", toknz->tmp.kls->name);
      toknz->tmp.kls = _eo_tokenizer_class_get(toknz, ( toknz->p));
      toknz->tmp.kls->type = toknz->tmp.kls_type;
   }
	break;
	case 35:
#line 990 "src/lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.typedef_alias = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 36:
#line 994 "src/lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.typedef_alias == NULL)
        ABORT(toknz, "No typedef");
      toknz->tmp.type_def = _eo_tokenizer_type_get(toknz, ( toknz->p));
      toknz->tmp.type_def->alias = toknz->tmp.typedef_alias;
      toknz->typedefs = eina_list_append(toknz->typedefs, toknz->tmp.type_def);
   }
	break;
	case 39:
#line 1 "NONE"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 40:
#line 464 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->comment != NULL)
        ABORT(toknz, "accessor has already a comment");
      toknz->tmp.accessor->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.accessor->comment);
   }}
	break;
	case 41:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 42:
#line 527 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 43:
#line 528 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 44:
#line 493 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 349; goto _again;}
   }}
	break;
	case 45:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 46:
#line 523 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 47:
#line 526 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 48:
#line 493 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 349; goto _again;}
   }}
	break;
	case 49:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 50:
#line 526 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 51:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 52:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 53:
#line 552 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 349; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 364; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 54:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 55:
#line 568 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 56:
#line 570 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 57:
#line 552 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 349; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 364; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 58:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 59:
#line 570 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 60:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 61:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 62:
#line 577 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      get {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, GETTER);
      toknz->current_nesting++;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 63:
#line 584 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      set {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, SETTER);
      toknz->current_nesting++;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 64:
#line 591 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      keys {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->keys);
      { toknz->cs = 342; goto _again;}
   }}
	break;
	case 65:
#line 598 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      values {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->values);
      { toknz->cs = 342; goto _again;}
   }}
	break;
	case 66:
#line 637 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 67:
#line 605 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 358; goto _again;}
   }}
	break;
	case 68:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 69:
#line 631 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 70:
#line 605 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 358; goto _again;}
   }}
	break;
	case 71:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 72:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 73:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 74:
#line 644 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      INF("    %s {", toknz->tmp.prop->name);
      toknz->current_nesting++;
      { toknz->cs = 349; goto _again;}
   }}
	break;
	case 75:
#line 661 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 76:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 77:
#line 670 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 78:
#line 661 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 79:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 80:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 81:
#line 679 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->comment != NULL)
        ABORT(toknz, "method has already a comment");
      toknz->tmp.meth->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.meth->comment);
   }}
	break;
	case 82:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 83:
#line 687 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("      params {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.meth->params);
      { toknz->cs = 342; goto _again;}
   }}
	break;
	case 84:
#line 767 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 85:
#line 768 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 86:
#line 769 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 87:
#line 728 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 88:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 89:
#line 762 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 90:
#line 766 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 91:
#line 728 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting--;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 92:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 93:
#line 766 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 94:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 95:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 96:
#line 776 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    %s {", toknz->tmp.meth->name);
      toknz->current_nesting++;
      { toknz->cs = 364; goto _again;}
   }}
	break;
	case 97:
#line 793 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 98:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 99:
#line 803 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 100:
#line 793 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 101:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 102:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 103:
#line 812 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->comment != NULL)
        ABORT(toknz, "class %s has already a comment", toknz->tmp.kls->name);
      toknz->tmp.kls->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
   }}
	break;
	case 104:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 105:
#line 830 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 106:
#line 833 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 107:
#line 836 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  constructors {");
      toknz->current_methods_type = METH_CONSTRUCTOR;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting++;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 108:
#line 844 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  properties {");
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting++;
      { toknz->cs = 358; goto _again;}
   }}
	break;
	case 109:
#line 851 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  begin methods");
      toknz->current_methods_type = METH_REGULAR;
      toknz->tmp.fscope = FUNC_PUBLIC;
      toknz->current_nesting++;
      { toknz->cs = 374; goto _again;}
   }}
	break;
	case 110:
#line 859 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 111:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 112:
#line 940 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 113:
#line 943 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 114:
#line 944 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 115:
#line 945 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 116:
#line 830 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 117:
#line 833 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 118:
#line 859 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 119:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 120:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 121:
#line 397 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 122:
#line 957 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("begin class: %s", toknz->tmp.kls->name);
      toknz->current_nesting++;
      { toknz->cs = 380; goto _again;}
   }}
	break;
	case 123:
#line 1010 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 124:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 125:
#line 1007 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 126:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 127:
#line 406 "src/lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
#line 4272 "src/lib/eolian/eo_lexer.c"
		}
	}

_again:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_to_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 37:
#line 1 "NONE"
	{ toknz->ts = 0;}
	break;
#line 4285 "src/lib/eolian/eo_lexer.c"
		}
	}

	if ( ++( toknz->p) != ( toknz->pe) )
		goto _resume;
	_test_eof: {}
	if ( ( toknz->p) == ( toknz->eof) )
	{
	if ( _eo_tokenizer_eof_trans[ toknz->cs] > 0 ) {
		_trans = _eo_tokenizer_eof_trans[ toknz->cs] - 1;
		goto _eof_trans;
	}
	}

	_out: {}
	}

#line 1117 "src/lib/eolian/eo_lexer.rl"

   if ( toknz->cs == 
#line 4306 "src/lib/eolian/eo_lexer.c"
-1
#line 1118 "src/lib/eolian/eo_lexer.rl"
 )
     {
        ERR("%s: wrong termination", source);
        ret = EINA_FALSE;
     }

   return ret;
}

Eo_Tokenizer*
eo_tokenizer_get(void)
{
   Eo_Tokenizer *toknz = calloc(1, sizeof(Eo_Tokenizer));
   if (!toknz) return NULL;

   toknz->ts = NULL;
   toknz->te = NULL;
   /* toknz->top = 0; */
   toknz->source = NULL;
   toknz->max_nesting = 10;
   toknz->current_line = 1;
   toknz->current_nesting = 0;
   toknz->current_methods_type = METH_TYPE_LAST;
   toknz->saved.tok = NULL;
   toknz->saved.line = 0;
   toknz->classes = NULL;
   toknz->typedefs = NULL;

   return toknz;
}

static char *_accessor_type_str[ACCESSOR_TYPE_LAST] = { "setter", "getter" };
static char *_param_way_str[PARAM_WAY_LAST] = { "IN", "OUT", "INOUT" };

void
eo_tokenizer_dump(Eo_Tokenizer *toknz)
{
   const char *s;
   Eina_List *k, *l, *m;

   Eo_Class_Def *kls;
   Eo_Property_Def *prop;
   Eo_Method_Def *meth;
   Eo_Param_Def *param;
   Eo_Accessor_Def *accessor;
   Eo_Event_Def *sgn;
   /* Eo_Ret_Def *ret; */

   EINA_LIST_FOREACH(toknz->classes, k, kls)
     {
        printf("Class: %s (%s)\n",
               kls->name, (kls->comment ? kls->comment : "-"));
        printf("  inherits from :");
        EINA_LIST_FOREACH(kls->inherits, l, s)
           printf(" %s", s);
        printf("\n");
        printf("  implements:");
        EINA_LIST_FOREACH(kls->implements, l, s)
           printf(" %s", s);
        printf("\n");
        printf("  events:\n");
        EINA_LIST_FOREACH(kls->events, l, sgn)
           printf("    %s <%s> (%s)\n", sgn->name, sgn->type, sgn->comment);

        EINA_LIST_FOREACH(kls->constructors, l, meth)
          {
             printf("  constructors: %s\n", meth->name);
             if (meth->ret)
                printf("    return: %s (%s)\n", meth->ret->type, meth->ret->comment);
             printf("    legacy : %s\n", meth->legacy);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  printf("    param: %s %s : %s (%s)\n",
                         _param_way_str[param->way], param->name,
                         param->type, param->comment);
               }
          }

        EINA_LIST_FOREACH(kls->properties, l, prop)
          {
             printf("  property: %s\n", prop->name);
             EINA_LIST_FOREACH(prop->keys, m, param)
               {
                  printf("    key: %s : %s (%s)\n",
                         param->name, param->type, param->comment);
               }
             EINA_LIST_FOREACH(prop->values, m, param)
               {
                  printf("    value: %s : %s (%s)\n",
                         param->name, param->type, param->comment);
               }
             EINA_LIST_FOREACH(prop->accessors, m, accessor)
               {
                  printf("    accessor: %s : %s (%s)\n",
                         (accessor->ret?accessor->ret->type:""),
                         _accessor_type_str[accessor->type],
                         accessor->comment);
                  printf("      legacy : %s\n", accessor->legacy);
               }
             printf("    is_ctor : %s\n", prop->is_ctor?"true":"false");
          }

        EINA_LIST_FOREACH(kls->methods, l, meth)
          {
             printf("  method: %s\n", meth->name);
             if (meth->ret)
                printf("    return: %s (%s)\n", meth->ret->type, meth->ret->comment);
             printf("    legacy : %s\n", meth->legacy);
             printf("    obj_const : %s\n", meth->obj_const?"true":"false");
             printf("    is_ctor : %s\n", meth->is_ctor?"true":"false");
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  printf("    param: %s %s : %s (%s)\n",
                         _param_way_str[param->way], param->name,
                         param->type, param->comment);
               }
          }

     }

}

static Eina_Inlist *
_types_extract(const char *buf, int len)
{
   const char *save_buf = buf;
   Eolian_Type types = NULL;
   long depth = 0;
   char *tmp_type = malloc(2 * len + 1);

   while (len > 0)
     {
        char *d = tmp_type;
        Eina_Bool end_type = EINA_FALSE;
        Eina_Bool is_own = EINA_FALSE;
        char c;
        Eina_Bool in_spaces = EINA_TRUE, in_stars = EINA_FALSE;
        while (len > 0 && !end_type)
          {
             switch (c = *buf++)
               {
                /* @own */
                case '@':
                     {
                        if (!strncmp(buf, "own ", 4))
                          {
                             is_own = EINA_TRUE;
                             buf += 4; len -= 4;
                          }
                        break;
                     }
                /* if '*', we have to add a space. We set in_spaces to true in
                 * case spaces are between stars, to be sure we remove them.
                 */
                case '*':
                     {
                        if (!in_stars && !in_spaces)
                          {
                             *d++ = ' ';
                             in_stars = EINA_TRUE;
                             in_spaces = EINA_TRUE;
                          }
                        *d++ = c;
                        break;
                     }
                /* Only the first space is inserted. */
                case ' ':
                     {
                        if (!in_spaces) *d++ = c;
                        in_spaces = EINA_TRUE;
                        break;
                     }
                case '<':
                     {
                        if (depth < 0)
                          {
                             ERR("%s: Cannot reopen < after >", save_buf);
                             goto error;
                          }
                        depth++;
                        end_type = EINA_TRUE;
                        break;
                     }
                case '>':
                     {
                        if (depth == 0)
                          {
                             ERR("%s: Too much >", save_buf);
                             goto error;
                          }
                        if (depth > 0 && d == tmp_type)
                          {
                             ERR("%s: empty type inside <>", save_buf);
                             goto error;
                          }
                        if (depth > 0) depth *= -1;
                        depth++;
                        end_type = EINA_TRUE;
                        break;
                     }
                default:
                     {
                        *d++ = c;
                        in_spaces = EINA_FALSE;
                        in_stars = EINA_FALSE;
                     }
               }
             len--;
          }
        if (d != tmp_type)
          {
             *d = '\0';
             types = database_type_append(types, tmp_type, is_own);
          }
     }
   if (depth)
     {
        ERR("%s: < and > are not well used.", save_buf);
        goto error;
     }
   goto success;
error:
   database_type_del(types);
   types = NULL;
success:
   free(tmp_type);
   return types;
}

Eina_Bool
eo_tokenizer_database_fill(const char *filename)
{
   Eina_Bool ret = EINA_FALSE;
   const char *s;
   Eina_List *k, *l, *m;

   Eo_Class_Def *kls;
   Eo_Type_Def *type_def;
   Eo_Property_Def *prop;
   Eo_Method_Def *meth;
   Eo_Param_Def *param;
   Eo_Accessor_Def *accessor;
   Eo_Event_Def *event;
   Eo_Implement_Def *impl;

   FILE *stream = NULL;
   char *buffer = NULL;

   Eo_Tokenizer *toknz = eo_tokenizer_get();
   if (!toknz)
     {
        ERR("can't create eo_tokenizer");
        goto end;
     }

   stream = fopen(filename, "rb");
   if (!stream)
     {
        ERR("unable to read in %s", filename);
        goto end;
     }

   buffer = malloc(BUFSIZE);
   if (!buffer)
     {
        ERR("unable to allocate read buffer");
        goto end;
     }

   unsigned int len = fread(buffer, 1, BUFSIZE, stream);

   if (!len)
     {
        ERR("%s: is an empty file", filename);
        goto end;
     }

   if (len == BUFSIZE)
     {
        ERR("%s: buffer(%d) is full, might not be big enough.", filename, len);
        goto end;
     }

   buffer[len] = '\0';
#if _WIN32
   {
      Eina_Strbuf *str_buffer = eina_strbuf_manage_new(buffer);
      if (eina_strbuf_replace_all(str_buffer, "\r\n", "\n"))
         len = eina_strbuf_length_get(str_buffer);
      buffer = eina_strbuf_string_steal(str_buffer);
      eina_strbuf_free(str_buffer);
   }
#endif
   if (!eo_tokenizer_mem_walk(toknz, filename, buffer, len)) goto end;

   if (!toknz->classes)
     {
        ERR("No classes for file %s", filename);
        goto end;
     }

   EINA_LIST_FOREACH(toknz->classes, k, kls)
     {
        Eolian_Class class = database_class_add(kls->name, kls->type);
        database_class_file_set(class, filename);

        if (kls->comment) database_class_description_set(class, kls->comment);

        EINA_LIST_FOREACH(kls->inherits, l, s)
           database_class_inherit_add(class, s);

        if (kls->legacy_prefix)
          {
             database_class_legacy_prefix_set(class, kls->legacy_prefix);
          }
        if (kls->eo_prefix)
          {
             database_class_eo_prefix_set(class, kls->eo_prefix);
          }
        if (kls->data_type)
          {
             database_class_data_type_set(class, kls->data_type);
          }
        EINA_LIST_FOREACH(kls->constructors, l, meth)
          {
             Eolian_Function foo_id = database_function_new(meth->name, EOLIAN_CTOR);
             database_class_function_add(class, foo_id);
             if (meth->ret) database_function_return_comment_set(foo_id, EOLIAN_METHOD, meth->ret->comment);
             database_function_data_set(foo_id, EOLIAN_LEGACY, meth->legacy);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  Eolian_Type type = _types_extract(param->type, strlen(param->type));
                  database_method_parameter_add(foo_id, (Eolian_Parameter_Dir)param->way, type, param->name, param->comment);
               }
          }

        EINA_LIST_FOREACH(kls->properties, l, prop)
          {
             Eolian_Function foo_id = database_function_new(prop->name, EOLIAN_UNRESOLVED);
             database_function_scope_set(foo_id, prop->scope);
             database_function_set_as_ctor(foo_id, prop->is_ctor);
             EINA_LIST_FOREACH(prop->keys, m, param)
               {
                  Eolian_Type type = _types_extract(param->type, strlen(param->type));
                  Eolian_Function_Parameter p = database_property_key_add(
                        foo_id, type, param->name, param->comment);
                  database_parameter_nonull_set(p, param->nonull);
               }
             EINA_LIST_FOREACH(prop->values, m, param)
               {
                  Eolian_Type type = _types_extract(param->type, strlen(param->type));
                  Eolian_Function_Parameter p = database_property_value_add(
                        foo_id, type, param->name, param->comment);
                  database_parameter_nonull_set(p, param->nonull);
               }
             EINA_LIST_FOREACH(prop->accessors, m, accessor)
               {
                  database_function_type_set(foo_id, (accessor->type == SETTER?EOLIAN_PROP_SET:EOLIAN_PROP_GET));
                  if (accessor->ret && accessor->ret->type)
                    {
                       Eolian_Function_Type ftype =
                          accessor->type == SETTER?EOLIAN_PROP_SET:EOLIAN_PROP_GET;
                       Eolian_Type types = _types_extract(accessor->ret->type, strlen(accessor->ret->type));
                       database_function_return_type_set(foo_id, ftype, types);
                       database_function_return_comment_set(foo_id,
                             ftype, accessor->ret->comment);
                       database_function_return_flag_set_as_warn_unused(foo_id,
                             ftype, accessor->ret->warn_unused);
                       database_function_return_dflt_val_set(foo_id,
                             ftype, accessor->ret->dflt_ret_val);
                    }
                  if (accessor->legacy)
                    {
                       database_function_data_set(foo_id,
                             (accessor->type == SETTER?EOLIAN_LEGACY_SET:EOLIAN_LEGACY_GET),
                             accessor->legacy);
                    }
                  database_function_description_set(foo_id,
                        (accessor->type == SETTER?EOLIAN_COMMENT_SET:EOLIAN_COMMENT_GET),
                        accessor->comment);
                  Eo_Accessor_Param *acc_param;
                  Eina_List *m2;
                  EINA_LIST_FOREACH(accessor->params, m2, acc_param)
                    {
                       Eolian_Function_Parameter desc = eolian_function_parameter_get(foo_id, acc_param->name);
                       if (!desc)
                         {
                            printf("Error - %s not known as parameter of property %s\n", acc_param->name, prop->name);
                         }
                       else
                          if (strstr(acc_param->attrs, "const"))
                            {
                               database_parameter_const_attribute_set(desc, accessor->type == GETTER, EINA_TRUE);
                            }
                    }
               }
             if (!prop->accessors) database_function_type_set(foo_id, EOLIAN_PROPERTY);
             database_class_function_add(class, foo_id);
          }

        EINA_LIST_FOREACH(kls->methods, l, meth)
          {
             Eolian_Function foo_id = database_function_new(meth->name, EOLIAN_METHOD);
             database_function_scope_set(foo_id, meth->scope);
             database_class_function_add(class, foo_id);
             if (meth->ret)
               {
                  Eolian_Type types = _types_extract(meth->ret->type, strlen(meth->ret->type));
                  database_function_return_type_set(foo_id, EOLIAN_METHOD, types);
                  database_function_return_comment_set(foo_id, EOLIAN_METHOD, meth->ret->comment);
                  database_function_return_flag_set_as_warn_unused(foo_id,
                        EOLIAN_METHOD, meth->ret->warn_unused);
                  database_function_return_dflt_val_set(foo_id,
                        EOLIAN_METHOD, meth->ret->dflt_ret_val);
               }
             database_function_description_set(foo_id, EOLIAN_COMMENT, meth->comment);
             database_function_data_set(foo_id, EOLIAN_LEGACY, meth->legacy);
             database_function_object_set_as_const(foo_id, meth->obj_const);
             database_function_set_as_ctor(foo_id, meth->is_ctor);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  Eolian_Type type = _types_extract(param->type, strlen(param->type));
                  Eolian_Function_Parameter p = database_method_parameter_add(foo_id,
                        (Eolian_Parameter_Dir)param->way, type, param->name, param->comment);
                  database_parameter_nonull_set(p, param->nonull);
               }
          }

        EINA_LIST_FOREACH(kls->implements, l, impl)
          {
             const char *impl_name = impl->meth_name;
             if (!strcmp(impl_name, "class::constructor"))
               {
                  database_class_ctor_enable_set(class, EINA_TRUE);
                  continue;
               }
             if (!strcmp(impl_name, "class::destructor"))
               {
                  database_class_dtor_enable_set(class, EINA_TRUE);
                  continue;
               }
             if (!strncmp(impl_name, "virtual::", 9))
               {
                  char *virtual_name = strdup(impl_name);
                  char *func = strstr(virtual_name, "::");
                  if (func) *func = '\0';
                  func += 2;
                  Eolian_Function_Type ftype = EOLIAN_UNRESOLVED;
                  char *type_as_str = strstr(func, "::");
                  if (type_as_str)
                    {
                       *type_as_str = '\0';
                       if (!strcmp(type_as_str+2, "set")) ftype = EOLIAN_PROP_SET;
                       else if (!strcmp(type_as_str+2, "get")) ftype = EOLIAN_PROP_GET;
                    }
                  /* Search the function into the existing functions of the current class */
                  Eolian_Function foo_id = eolian_class_function_find_by_name(
                        class, func, ftype);
                  free(virtual_name);
                  if (!foo_id)
                    {
                       ERR("Error - %s not known in class %s", impl_name + 9, eolian_class_name_get(class));
                       goto end;
                    }
                  database_function_set_as_virtual_pure(foo_id, ftype);
                  continue;
               }
             Eolian_Implement impl_desc = database_implement_new(impl_name);
             database_class_implement_add(class, impl_desc);
          }

        EINA_LIST_FOREACH(kls->events, l, event)
          {
             Eolian_Event ev = database_event_new(event->name, event->type, event->comment);
             database_class_event_add(class, ev);
          }

     }

   EINA_LIST_FOREACH(toknz->typedefs, k, type_def)
     {
        database_type_add(type_def->alias, _types_extract(type_def->type, strlen(type_def->type)));
     }

   ret = EINA_TRUE;
end:
   if (buffer) free(buffer);
   if (stream) fclose(stream);
   if (toknz) eo_tokenizer_free(toknz);
   return ret;
}

void
eo_tokenizer_free(Eo_Tokenizer *toknz)
{
   Eo_Class_Def *kls;
   Eo_Type_Def *type;

   if (toknz->source)
     eina_stringshare_del(toknz->source);

   EINA_LIST_FREE(toknz->classes, kls)
      eo_definitions_class_def_free(kls);

   EINA_LIST_FREE(toknz->typedefs, type)
      eo_definitions_type_def_free(type);

   free(toknz);
}

